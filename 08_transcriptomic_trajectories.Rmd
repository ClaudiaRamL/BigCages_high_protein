---
title: "High-Protein BigCages - classify gene expression trajectories"
Author: "Claudia Ramirez-lanzas"
Date: "27/05/2024"
---

# Load libraries:
```{r}
# Plotting:
library("readxl") 
library("writexl") 
library("tidyverse") 

# Plotting
library("khroma") # plotting colour blind safe
library("ggplot2") 
library("patchwork") # to combine plots
library("svglite") 
library("egg") #
library("pheatmap") 
library("RColorBrewer") 
library("scatterplot3d") 
library("lessR") # pie charts
library("scales") # labeling in percentages
library("ggbreak")

# Statistical operations and data analysis:
library("car")
library("edgeR") # To create object for PCA
library("vegan") # to perform permanova test on PCA groups
library("rstatix") 


```
# Check sessionInfo:
```{r}
sessionInfo()
```
# Set-up colors:
```{r}
bright <- color("bright")
plot_scheme(bright(6), colours = TRUE, names = TRUE, size = 0.9)
#
muted <- color("muted")
plot_scheme(muted(9), colours = TRUE, names = TRUE, size = 0.9)

color_plateau <- muted(9)[2] #"#332288"
color_monotonic <- muted(9)[7] #"#44AA99"
color_late_response <-  "#D4AF37"
color_incomplete_reversed <- muted(9)[9] #"#AA4499"
color_complete_reversed <- muted(9)[5] #"#88CCEE" 
color_shared <- muted(9)[1] #"#CC6677" 

plot_scheme(muted(9)[2], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[7], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[9], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[3], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[5], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[1], colours = TRUE, names = TRUE, size = 0.9)


```
# Import files:
```{r}
DE_overall_results <- read_csv("input_files/DE_overall_results.csv", show_col_types = FALSE)

count_table <- read.delim("input_files/count_table.csv", sep=";")
count_table <- count_table %>% column_to_rownames(var = "gene_id")

DE_rep_specific_results <- read_csv("input_files/DE_repwise_results.csv", show_col_types = FALSE)

```

* DE_overall_results: contains the results of DE analysis using dream model. 
Including 3 contrasts: Base vs F7, Base vs F31 and F7 vs F31. P-values corrected across the 3 contrasts using the fdr method.

* count_table: .csv file  containing the RNA count table (the output of featureCounts function from subRead). Each column is a sample and each row a gene.It contains 5 samples from Base (F0), 18 samples from Big populations at F7 and 18 samples at F31.
The samples are labeled with biological names. 

* DE_rep_specific_results: contains the results of replicate wise DE analysis. 
P-values are corrected across 3 contrasts.

# Count table after filtering low expression.
Same set of genes used for DE analysis and PCA analysis.
```{r}
#Library size = Total number of fragments (paired ends) mapped to the genome. 
lib_size <- colSums(count_table)
hist(lib_size)
average_library_size <- mean(lib_size) # 10 millions
average_library_size


### Remove lowly expressed genes:
#Set CPM threshold:
CPM_threshold <- 1 

# Create filtered count table:
count_table_filt <- count_table[apply(cpm(count_table), 1, function(x){!(sum(x < CPM_threshold) >= 1)}),] # If there is one sample or more with CPM < threshold then the gene is filtered out. 

# print filtering summary:
paste("all genes:", nrow(count_table))
paste("genes available after filtering:", nrow(count_table_filt))
paste("genes discarded", nrow(count_table) - nrow(count_table_filt))
paste("% genes discarded" , ((nrow(count_table) - nrow(count_table_filt))/nrow(count_table))*100)

```
## Function 1 - Plotting PCAs
```{r}
# PCA without labels:
plot_pca <- function(dat, aesx, aesy, color, mytitle, scale_color_set, shape_set, PCX, PCY) {
  ggplot2::ggplot(data = dat, aes_string(x = aesx, y = aesy, color = color, shape = color)) +
  geom_point(size = 3) + 
  scale_shape_manual(values = shape_set)  +
  scale_color_manual(values = scale_color_set) +
  theme_classic() + 
  theme(
    legend.title = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
      text = element_text(size = 11)) +
  labs(title=mytitle) +
  xlab(paste0(aesx," (",round(ve[PCX]*100,2),"%)")) +
  ylab(paste0(aesy," (",round(ve[PCY]*100,2),"%)")) + 
    scale_color_set +
  theme(axis.text = element_text(size = 12),  
        axis.title = element_text(size = 14),  
        axis.ticks = element_line(size = 1),
        legend.text=element_text(size=14))

}

# PCA labeling the replicates:
plot_pca_label_rep <- function(dat, aesx, aesy, color, mytitle, scale_color_set, shape_set, PCX, PCY) {
  ggplot2::ggplot(data = dat, aes_string(x = aesx, y = aesy, color = color, shape = color)) +
  geom_point(size = 4) + 
    geom_text(aes(label = rep), vjust = -1.5) +
  scale_shape_manual(values = shape_set)  +
  scale_color_manual(values = scale_color_set) +
  theme_classic() + 
  theme(
    legend.title = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
      text = element_text(size = 11)) +
  labs(title=mytitle) +
  xlab(paste0(aesx," (",round(ve[PCX]*100,2),"%)")) +
  ylab(paste0(aesy," (",round(ve[PCY]*100,2),"%)")) + 
    scale_color_set +
  theme(axis.text = element_text(size = 12),  
        axis.title = element_text(size = 14),  
        axis.ticks = element_line(size = 1))  
}

```
## Function 2 - Classify trajectories
```{r}
classify_DEGs <- function(df, alpha_thresh = 0.05, logFC_thresh = 0) {
  # Create empty columns
  df$group <- "NA"
  df$direction <- "NA"
  
    # Define logical conditions:
  non_significant <- df$padj_F7 > alpha_thresh & df$padj_F31 > alpha_thresh & df$padj_F7_F31 > alpha_thresh
  plateau_up <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 > alpha_thresh & df$logFC_F31 > logFC_thresh
  plateau_down <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 > alpha_thresh & df$logFC_F31 < logFC_thresh
  transitory_F7_F31 <- df$padj_F7 > alpha_thresh & df$padj_F31 > alpha_thresh & df$padj_F7_F31 < alpha_thresh
  F7_private_up <- df$padj_F7 < alpha_thresh & df$padj_F31 > alpha_thresh & df$logFC_F7 > logFC_thresh
  F7_private_down <- df$padj_F7 < alpha_thresh & df$padj_F31 > alpha_thresh & df$logFC_F7 < logFC_thresh
  F31_private_up <- df$padj_F7 > alpha_thresh & df$padj_F31 < alpha_thresh & df$logFC_F31 > logFC_thresh
  monotonic_up <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 < alpha_thresh & (df$logFC_F7 > logFC_thresh & df$logFC_F31 > logFC_thresh) & df$logFC_F7 < df$logFC_F31
  reversed_up <- df$padj_F7_F31 < alpha_thresh & df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & (df$logFC_F7 > logFC_thresh & df$logFC_F7 > df$logFC_F31)
  F31_private_down <- df$padj_F7 > alpha_thresh & df$padj_F31 < alpha_thresh & df$logFC_F31 < logFC_thresh
  monotonic_down <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 < alpha_thresh & (df$logFC_F7 < logFC_thresh & df$logFC_F31 < logFC_thresh) & df$logFC_F7 > df$logFC_F31
  reversed_down <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 < alpha_thresh & (df$logFC_F7 < logFC_thresh & df$logFC_F7 < df$logFC_F31)
  
  # Apply classifications:
  df$group[non_significant] <- "non_significant"
  df$direction[non_significant] <- "none"
  df$group[plateau_up] <- "plateau"
  df$direction[plateau_up] <- "up"
  df$group[plateau_down] <- "plateau"
  df$direction[plateau_down] <- "down"
  df$group[transitory_F7_F31] <- "non_significant"
  df$direction[transitory_F7_F31] <- "none"
  df$group[F7_private_up] <- "complete_reversed"
  df$direction[F7_private_up] <- "up"
  df$group[F7_private_down] <- "complete_reversed"
  df$direction[F7_private_down] <- "down"
  df$group[F31_private_up] <- "late_response"
  df$direction[F31_private_up] <- "up"
  df$group[monotonic_up] <- "monotonic"
  df$direction[monotonic_up] <- "up"
  df$group[reversed_up] <- "incomplete_reversed"
  df$direction[reversed_up] <- "up"
  df$group[F31_private_down] <- "late_response"
  df$direction[F31_private_down] <- "down"
  df$group[monotonic_down] <- "monotonic"
  df$direction[monotonic_down] <- "down"
  df$group[reversed_down] <- "incomplete_reversed"
  df$direction[reversed_down] <- "down"
  
  return(df)
 
  }

```

# # PART 1: Correlation of transcriptomic response
Plot the correlation of transcriptomic response (log2FC) between F7 and F31.
# Prepare dataset:
```{r}
# Check No of transitory genes: contrast "dream_F31_F7":
nrow(DE_overall_results %>% dplyr::filter(contrast == "dream_F31_F7" & padj_fdr < 0.05))

# Remove the contrast "dream_F31_F7":
DE_results_filt <- DE_overall_results %>% dplyr::filter(contrast != "dream_F31_F7") 

# Keep only needed columns:
DE_results_short <- DE_results_filt %>% 
  dplyr::select("gene_id", "logFC", "padj_fdr", "contrast")

# Change column names:
colnames(DE_results_short) <- c("gene_id", "logFC", "padj", "contrast")

# From wide to long:
DE_results_wide <- DE_results_short %>%
  pivot_wider(
    names_from = contrast,
    values_from = c(logFC, padj))

colnames(DE_results_wide) <- c("gene_id",
                              "logFCF7", 
                              "logFCF31",
                              "padjF7",
                              "padjF31")

```
# Classify genes - 3 groups
shared: DEGs at both base vs F7 and base vs F31
F7_specific: DEGs only at base vs F7
F31_specific: DEGs only at base vs F31
not_sig: not significant change when compared to base.

```{r}
DE_results_wide <- DE_results_wide %>% 
  dplyr::mutate(label = case_when(
  padjF7 < 0.05  & padjF31 < 0.05 ~ "shared",
  padjF7 < 0.05  & padjF31 >= 0.05 ~ "F7_specific",
  padjF7 >= 0.05  & padjF31 < 0.05 ~ "F31_specific",
  padjF7 >=  0.05 & padjF31 >=  0.05 ~ "not_sig",
  TRUE ~ "NA"))

# Relevel contrasts:
DE_results_wide$label <- factor(DE_results_wide$label,
                                levels = c("not_sig",
                                           "F7_specific",
                                           "F31_specific",
                                           "shared"))

# Check No DEGs in each group:
table(DE_results_wide$label)
# Total number of DEGs between Base and evolved populations at F7 and F31:
nrow(DE_results_wide %>% dplyr::filter(label %in% c("shared", "F7_specific", "F31_specific")))

# Plotting: 
plot_df <- as.data.frame(table(DE_results_wide$label))
plot_df %>%
  ggplot(aes( x = Var1, y = Freq)) + 
  geom_bar(stat = "identity") + 
  ggtitle("Summary of DE analysis") +
  xlab("contrast") +
  ylab("No DEGs") +
  theme_classic()

```
# Figure 2:
```{r}

plot_df <- DE_results_wide
# Relabel groups:

plot_df <- plot_df %>%
  dplyr::mutate(label = case_when(label == "F7_specific" ~ "complete_reversed",
                                  label == "F31_specific" ~ "late_response",
                                  label == "shared" ~ "shared",
                                  TRUE ~ label))
# Create variables for legend:
shared_nb <- nrow(plot_df %>% dplyr::filter(label == "shared"))
not_sig_nb <- nrow(plot_df %>% dplyr::filter(label == "not_sig"))
complete_reversed_nb <- nrow(plot_df %>% dplyr::filter(label == "complete_reversed"))
late_response_nb <- nrow(plot_df %>% dplyr::filter(label == "late_response"))

# Relevel label:
plot_df$label <- factor(plot_df$label, levels = c("not_sig",
                                                  "shared",
                                                  "complete_reversed",
                                                  "late_response" ))


# Plotting: 
plot_df %>% 
  arrange(label) %>% 
  ggplot(aes(x = logFCF7, y = logFCF31, colour = label)) + 
  geom_point(size=2, shape=16) +
  xlim(c(-6, 6)) +
  ylim(c(-6, 6)) +
  xlab(bquote(log[2]*FC~Gen~7)) + 
  ylab(bquote(log[2]*FC~Gen~31)) + 
  theme_light() + 
  coord_fixed() +
# Add ablines
  geom_abline(intercept = 0, slope = 0, linetype = "dashed", color = "grey70") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey70") +
  geom_abline(intercept = 0, slope = -1, linetype = "dashed", color = "grey70") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey70")+
  scale_color_manual(values = c("not_sig" = "grey",
                                "shared" = color_shared,
                                "complete_reversed" = color_complete_reversed,
                                "late_response" = color_late_response),
                    name = "", 
                    labels = c(
                      paste("Not significant:", not_sig_nb),
                      paste("Shared:", shared_nb),
                            paste("Complete-reverse:", complete_reversed_nb), 
                            paste("Late-response:", late_response_nb))) + 
  guides(color = guide_legend(override.aes = list(size = 5))) + 
  guides(color = guide_legend(override.aes = list(size = 5))) +
  theme_linedraw() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 14),  
        axis.title = element_text(size = 14),  
        axis.ticks = element_line(size = 1),
        panel.border = element_rect(color = "black", fill = NA, size = 1)) +
  scale_x_continuous(breaks = c(-8, -6, -4, -2, 0, 2, 4, 6, 8), limits = c(-8, 8)) +
  scale_y_continuous(breaks = c(8, -6, -4, -2, 0, 2, 4, 6, 8), limits = c(-8, 8)) 

# Save plot:
#ggsave(plot = last_plot(), "output_files/plots/correlation_plots_and_trajectories/latest_version/corr_plot.svg", 
       #width = 200, 
       #units = "mm", 
       #dpi = 200)

#ggsave(plot = last_plot(), "output_files/plots/correlation_plots_and_trajectories/latest_version/corr_plot.png", 
       #width = 150,
       #height = 150, 
       #units = "mm", 
       #dpi = 400)

```
# Summary:
```{r}

# Correlation coefficient - all genes:
pearson_cor <- cor(DE_results_wide$logFCF7, DE_results_wide$logFCF31, method = "pearson")
# Correlation coefficient - only shared DEGs:
shared <- DE_results_wide %>% dplyr::filter(label == "shared")
pearson_cor_shared <- cor(shared$logFCF7, shared$logFCF31, method = "pearson")

# Total number DGEGs at either generation:
total_degs <- nrow(DE_results_wide %>% dplyr::filter(label != "not_sig"))
# Total number DGEGs shared between F7 and F31:
total_shared <- nrow(shared)
# Proportion shared:
prop_shared <- (nrow(shared) / nrow(DE_results_wide %>% dplyr::filter(label != "not_sig"))) * 100
# Total n DGEGs at F7:
degs_F7 <- nrow(DE_results_wide %>% dplyr::filter(label %in% c("F7_specific", "shared")))
# Total n DGEGs at F31:
degs_F31 <- nrow(DE_results_wide %>% dplyr::filter(label %in% c("F31_specific", "shared")))
# Specific DGEGs at F7:
degs_specific_F7 <- nrow(DE_results_wide %>% dplyr::filter(label %in% c("F7_specific")))
# Specific DGEGs at F32:
degs_specific_F31 <- nrow(DE_results_wide %>% dplyr::filter(label %in% c("F31_specific")))

# Proportion Specific DGEGs at F7:
degs_prop_specific_F7 <- nrow(DE_results_wide %>% dplyr::filter(label == "F7_specific")) / nrow(DE_results_wide %>% dplyr::filter(label != "not_sig")) * 100
# Proportion Specific DGEGs at F31:
degs_prop_specific_F31 <- nrow(DE_results_wide %>% dplyr::filter(label == "F31_specific")) / nrow(DE_results_wide %>% dplyr::filter(label != "not_sig")) * 100


# Print summary:
paste("Correlation coefficient all genes:", as.character(pearson_cor))
paste("Correlation coefficient of only shared DEGs:", as.character(pearson_cor_shared))
paste("Total DEGs at either generation:", as.character(total_degs))
paste("Total shared DEGs:", as.character(total_shared))
paste("Proportion of shared DEGs:", as.character(prop_shared))
paste("Total n DGEGs at F7:", as.character(degs_F7))
paste("Total n DGEGs at F31:", as.character(degs_F31))
paste("Specific n DGEGs at F7:", as.character(degs_specific_F7))
paste("Specific n DGEGs at F31:", as.character(degs_specific_F31))

paste("Proportion Specific n DGEGs at F7:", as.character(degs_prop_specific_F7))
paste("proportion Specific n DGEGs at F31:", as.character(degs_prop_specific_F31))

```
# # PART 2: Classify gene trajectories (overall model DEGs)
Classify the trajectories of genes across 3 time points. 
Use p-value and direction of log2FC.
# Prepare dataset:
```{r}
# Remove unnecessary columns:
DE_results_dream_short <- DE_overall_results %>% 
  dplyr::select(c("gene_id","logFC", "contrast", "padj_fdr"))

# From wide to long:
DE_results_wide <- DE_results_dream_short %>%
  pivot_wider(
    names_from = contrast,
    values_from = c(logFC, padj_fdr))

# Change column names:
colnames(DE_results_wide) <- c("gene_id", 
                           "logFC_F7",
                           "logFC_F31", 
                           "logFC_F7_F31",
                           "padj_F7", 
                           "padj_F31",
                           "padj_F7_F31")

```
# Classify genes:
```{r}

# Use classify_DEGs function to classify trajectories across 3 generations:
classify_df <-  classify_DEGs(df = DE_results_wide, alpha_thresh = 0.05, logFC_thresh = 0)

# Check the genes per group:
table(classify_df$group, classify_df$direction)

# Include full group variable:
classify_df$full_group <- paste(classify_df$group, classify_df$direction, sep = "_")
classify_df <- classify_df %>% dplyr::relocate(full_group, .after = direction)

# Format variables:
classify_df$group <- as.factor(classify_df$group)
classify_df$full_group <- as.factor(classify_df$full_group)

# Arrange levels of group:
classify_df$group <-  factor(classify_df$group,
                             levels = c("non_significant",
                                        "plateau", 
                                        "monotonic", 
                                        "incomplete_reversed", 
                                        "complete_reversed", 
                                        "late_response"))


```
# Plot - gene trajectories
In order to have one value per gene and simplify the plot we compute
the median log2CPM across samples of the same generation. 
## Prepare data-set:
```{r}
# Convert gene_id into row names:
count_table_df <- count_table_filt 

# Compute log2CPM:
log2CPM <- edgeR::cpm(as.matrix(count_table_df), 
        normalized.lib.sizes = TRUE,
       log = TRUE)

# Convert gene_id into a column:
log2CPM <- rownames_to_column(as.data.frame(log2CPM), var = "gene_id")

# Include classification information:
group_df <- classify_df %>% dplyr::select(c(gene_id, group, direction, full_group))

log2CPM_group <- inner_join(log2CPM, group_df, by = "gene_id")
log2CPM_group <- relocate(log2CPM_group, group, .after = gene_id)
log2CPM_group <- relocate(log2CPM_group, direction, .after = group)
log2CPM_group <- relocate(log2CPM_group, full_group, .after = direction)

# Final data-set:
log2CPM_classify <- log2CPM_group

## Compute mean log2CPM:
#Mean log2CPM of a gene across samples within generation.
# Note: log2CPM_classify has to be ordered properly columnwise!

# Calculate the median of base
log2CPM_classify$F0 <- apply(log2CPM_classify[, 5:9], 1, mean)
# Calculate the median of F7
log2CPM_classify$F07 <- apply(log2CPM_classify[, 10:27], 1, mean)
# Calculate the median of F31
log2CPM_classify$F31 <- apply(log2CPM_classify[, 28:45], 1, mean)

# Keep needed columns:
mean_log2CPM_matrix <- log2CPM_classify %>%
  dplyr::select("gene_id", "group", "direction", "full_group", "F0", "F07", "F31")

# Remove "non significant" genes before scaling:
transform_df <- mean_log2CPM_matrix %>% 
  dplyr::filter(group != "non_significant") 

```
The Median log2CPM of each gene is scaled across generations. 
```{r}
# Function to compute Z-score:
cal_z_score <- function(x){
  (x - mean(x)) / sd(x)}

# log2CPM to long format:

transform_df <- transform_df %>% pivot_longer(cols = c("F0", "F07", "F31"), 
                                                names_to = "gen", 
                                                values_to = "mean_log2CPM")
# Compute z-scores for each group across generations:
transform_df <- transform_df %>% group_by(gene_id) %>%  
 mutate(scaled_mean_log2CPM = cal_z_score(mean_log2CPM)) %>% ungroup()

scaled_mean_log2CPM_df <- transform_df


# Reorder the factors:
scaled_mean_log2CPM_df$full_group <- factor(scaled_mean_log2CPM_df$full_group,
                                                  levels = c("plateau_up",
                                                             "monotonic_up",
                                                             "late_response_up",
                                                             "incomplete_reversed_up",
                                                             "complete_reversed_up",
                                                             "plateau_down",
                                                             "monotonic_down",
                                                             "late_response_down",
                                                             "incomplete_reversed_down",
                                                             "complete_reversed_down"))
```
## Plot mean log2CPM
```{r}
## Set facet tittles:
facet_labels <- c(
  "plateau_up" = "Plateau up",
  "plateau_down" = "Plateau down",
  "monotonic_up" = "Evolving Monotonic up",
  "monotonic_down" = "Evolving Monotonic down",
  "incomplete_reversed_up" = "Incomplete Reversed up",
  "incomplete_reversed_down" = "Incomplete Reversed down",
  "complete_reversed_up" = "Complete Reversed up",
  "complete_reversed_down" = "Complete Reversed down",
  "late_response_up" = "Late Response up",
  "late_response_down" = "Late Response down")

# Label number of genes;
my_tag <- c(paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "plateau_up")))),
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "plateau_down")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "evolving_up")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "evolving_down")))),
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "F31_private_up")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "F31_private_down")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "reversed_up")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "reversed_down")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "F7_private_up")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "F7_private_down")))))

# Change generation scale to reduce distances proportionally:
scaled_mean_log2CPM_df <- scaled_mean_log2CPM_df %>%
  dplyr::mutate(gen2 = case_when(gen == "F0" ~ 0, 
                                gen == "F07" ~ 0.5,
                                gen == "F31" ~ 2))


scaled_mean_log2CPM_df %>% 
  ggplot(aes(x = gen2, y = mean_log2CPM, group=interaction(full_group, gen2))) +
  geom_boxplot(aes(color = full_group), width=0.4) +
  scale_color_manual(values =  c(color_plateau, 
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed,
                               color_plateau, 
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed)) +
  facet_wrap(~ full_group,
             scale = "free_y",
             ncol = 5, nrow = 2,
             labeller = as_labeller(facet_labels)) +
  xlab("Generation") + 
  ylab(bquote(Mean~expression~change~log[2]*FC)) +
  theme_linedraw() +
  theme(strip.text = element_text(color = "black",
                                  size = 14),
        strip.background = element_blank(),
        legend.position = "none",
        plot.background = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        element_text(size=14),
        axis.text.y = element_text(size = 14,
                                   color = "black"),
                axis.text.x = element_text(size = 14,
                                   color = "black"),
        axis.ticks = element_line(colour = "black",
                                  size = 1)) + 
  scale_x_continuous(breaks = c(0, 0.5, 2), labels = c("0", "7", "31"))


```
## Plot z-score 
The Median log2CPM of each gene is scaled across generations. 
```{r}

scaled_mean_log2CPM_df %>% 
  ggplot(aes(x = gen2, y = scaled_mean_log2CPM, group=interaction(full_group, gen2))) +
  geom_boxplot(aes(color = full_group), width=0.4) +
  scale_color_manual(values =  c(color_plateau, 
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed,
                               color_plateau, 
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed)) +
  facet_wrap(~ full_group,
             scale = "free_y",
             ncol = 5, nrow = 2,
             #labeller = as_labeller(facet_labels)
             ) +
  xlab("Generation") + 
  ylab("Expression (mean log2CPM") + 
  theme_linedraw() +
  theme(strip.text = element_text(color = "black",
                                  size = 14),
        strip.background = element_blank(),
        legend.position = "none",
        plot.background = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        element_text(size=14),
        axis.text.y = element_text(size = 14,
                                   color = "black"),
                axis.text.x = element_text(size = 14,
                                   color = "black"),
        axis.ticks = element_line(colour = "black",
                                  size = 1)) + 
  scale_x_continuous(breaks = c(0, 0.5, 2), labels = c("0", "7", "31"))


```
## Plot Heat-map:
The Median log2CPM of each gene is be scaled across generations. 
```{r}
# Create data with log2CPM:
data <- log2CPM_group %>% dplyr::filter(group %in% c("monotonic",
                                                   "late_response")) 
data <- data %>% column_to_rownames("gene_id")
data <- data %>% arrange(full_group)
# Create a data frame for row annotation (groups)
group_df <- data.frame(full_group = factor(data$full_group))
row.names(group_df) <- rownames(data)
# Subset log2CPM values:
data <- data[,4:44] 

ann_df <- data.frame(generation = rep(c("Base", "F7", "F31"), c(5, 18, 18)))
row.names(ann_df) <- colnames(data)


# Create metadata:
filter_group_df <- log2CPM_group %>%
  dplyr::filter(full_group %in% c("monotonic_up",
                                  "monotonic_down",
                                  "late_response_up",
                                  "late_response_down"))
filter_ann_colors <- list(
  full_group =  c("monotonic_up" = "#b3de69",
             "monotonic_down" = "#31a354",
             "late_response_up" = "#bd0026",
             "late_response_down" = "#e31a1c"),
  
  generation = c("Base" = "orange",
              "F7" = "#af8dc3",
            "F31" = "#762a83"))
 
heat_plot1 <- pheatmap(data,
                      scale = "row",
                      col = brewer.pal(9, 'YlOrRd'), # choose a colour scale for your data
                      cluster_rows = F, 
                      cluster_cols = F, # set to FALSE if you want to remove the dendograms
                      clustering_distance_cols = 'euclidean',
                      clustering_distance_rows = 'euclidean',
                      clustering_method = 'ward.D',
                      annotation_row = group_df, # row (gene) annotations
                      annotation_col = ann_df, # column (sample) annotations
                      annotation_colors = filter_ann_colors, # colours for your annotations
                      annotation_names_row = F, 
                      annotation_names_col = F,
                      fontsize_row = 10,          # row label font size
                      fontsize_col = 7,          # column label font size 
                      angle_col = 90, # sample names at an angle
                      legend_breaks = c(-4,  4), # legend customisation
                      legend_labels = c("Low",  "High"), # legend customisation
                      show_colnames = T, show_rownames = F, # displaying column and row names
                      main = "scaled log2CPM DEGs") # a title for our heatmap
heat_plot1

```

```{r}
# Create data with log2CPM:
data <- log2CPM_group %>% dplyr::filter(group %in% c("complete_reversed",
                                                   "incomplete_reversed")) 
data <- data %>% column_to_rownames("gene_id")
data <- data %>% arrange(full_group)
# Create a data frame for row annotation (groups)
group_df <- data.frame(full_group = factor(data$full_group))
row.names(group_df) <- rownames(data)
# Subset log2CPM values:
data <- data[,4:44] 

ann_df <- data.frame(generation = rep(c("Base", "F7", "F31"), c(5, 18, 18)))
row.names(ann_df) <- colnames(data)


filter_group_df <- group_df %>%
  dplyr::filter(full_group %in% c("incomplete_reversed_up",
                                  "incomplete_reversed_down",
                                  "complete_reversed_up",
                                  "complete_reversed_down"))
filter_ann_colors <- list(
  full_group =  c("incomplete_reversed_up" = "#fdb479",
             "incomplete_reversed_down" = "#fdb930",
             "complete_reversed_up" = "#1dd3c9",
             "complete_reversed_down" = "#41b6c4"), 
  
  generation = c("Base" = "orange",
              "F7" = "#af8dc3",
            "F31" = "#762a83"))
 
##### 
heat_plot2 <- pheatmap(data,
                      scale = "row",
                      col = brewer.pal(9, 'YlOrRd'), # choose a colour scale for your data
                      cluster_rows = F, 
                      cluster_cols = F, # set to FALSE if you want to remove the dendograms
                      clustering_distance_cols = 'euclidean',
                      clustering_distance_rows = 'euclidean',
                      clustering_method = 'ward.D',
                      annotation_row = filter_group_df, # row (gene) annotations
                      annotation_col = ann_df, # column (sample) annotations
                      annotation_colors = filter_ann_colors, # colours for your annotations
                      annotation_names_row = F, 
                      annotation_names_col = F,
                      fontsize_row = 10,          # row label font size
                      fontsize_col = 7,          # column label font size 
                      angle_col = 90, # sample names at an angle
                      legend_breaks = c(-4,  4), # legend customisation
                      legend_labels = c("Low",  "High"), # legend customisation
                      show_colnames = T, show_rownames = F, # displaying column and row names
                      main = "scaled log2CPM DEGs") # a title for our heatmap
heat_plot2
```


```{r}
data <- log2CPM_group %>% dplyr::filter(group == "plateau") 
data <- data %>% column_to_rownames("gene_id")
data <- data %>% arrange(full_group)
# Create a data frame for row annotation (groups)
group_df <- data.frame(full_group = factor(data$full_group))
row.names(group_df) <- rownames(data)
# Subset log2CPM values:
data <- data[,4:44] 

ann_df <- data.frame(generation = rep(c("Base", "F7", "F31"), c(5, 18, 18)))
row.names(ann_df) <- colnames(data)

filter_group_df <- group_df %>%
  dplyr::filter(full_group %in% c("plateau_up",
                                  "plateau_down"))
filter_ann_colors <- list(
  full_group =  c("plateau_up" = "#3182bd",
             "plateau_down" = "#99b9d9"), 
  generation = c("Base" = "orange",
              "F7" = "#af8dc3",
            "F31" = "#762a83"))
 
heat_plot3 <- pheatmap(data,
                      scale = "row",
                      col = brewer.pal(9, 'YlOrRd'), # choose a colour scale for your data
                      cluster_rows = F, 
                      cluster_cols = F, # set to FALSE if you want to remove the dendograms
                      clustering_distance_cols = 'euclidean',
                      clustering_distance_rows = 'euclidean',
                      clustering_method = 'ward.D',
                      annotation_row = filter_group_df, # row (gene) annotations
                      annotation_col = ann_df, # column (sample) annotations
                      annotation_colors = filter_ann_colors, # colours for your annotations
                      annotation_names_row = F, 
                      annotation_names_col = F,
                      fontsize_row = 10,          # row label font size
                      fontsize_col = 7,          # column label font size 
                      angle_col = 90, # sample names at an angle
                      legend_breaks = c(-4,  4), # legend customisation
                      legend_labels = c("Low",  "High"), # legend customisation
                      show_colnames = T, show_rownames = F, # displaying column and row names
                      main = "scaled log2CPM DEGs") # a title for our heatmap
heat_plot3

```
## Plot log2FC:
Base is set artificially at 0 for all log2FC values to have a basal point 
from where to start the trajectories. 
```{r}
# Prepare data-set:
classify_df_long <-  classify_df %>% dplyr::select(-c(padj_F7,
                                                      padj_F31,
                                                      padj_F7_F31,
                                                      logFC_F7_F31 ))

classify_df_long <- pivot_longer(classify_df_long,
                                 cols = starts_with("logFC"),
                                 names_to = "contrast",
                                 values_to = "logFC")

classify_df_long$contrast <- factor(classify_df_long$contrast,
                                    levels = c("logFC_F7",
                                               "logFC_F31"))

table(classify_df_long$group)

```

```{r}
pu <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="plateau_up") %>% dplyr::select(gene_id),  
  full_group = "plateau_up",                   
  contrast = "Base",                
  logFC = 0 )

pd <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="plateau_down") %>% dplyr::select(gene_id),  
  full_group = "plateau_down",                   
  contrast = "Base",                
  logFC = 0 )

eu <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="monotonic_up") %>% dplyr::select(gene_id),  
  full_group = "monotonic_up",                   
  contrast = "Base",                
  logFC = 0 )

ed <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="monotonic_down") %>% dplyr::select(gene_id),  
  full_group = "monotonic_down",                   
  contrast = "Base",                
  logFC = 0 )

ru <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="incomplete_reversed_up") %>% dplyr::select(gene_id),  
  full_group = "incomplete_reversed_up",                   
  contrast = "Base",                
  logFC = 0 )

rd <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="incomplete_reversed_down") %>% dplyr::select(gene_id),  
  full_group = "incomplete_reversed_down",                   
  contrast = "Base",                
  logFC = 0)

pr7u <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="complete_reversed_up") %>% dplyr::select(gene_id),  
  full_group = "complete_reversed_up",                   
  contrast = "Base",                
  logFC = 0)

pr7d <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="complete_reversed_down") %>% dplyr::select(gene_id),  
  full_group = "complete_reversed_down",                   
  contrast = "Base",                
  logFC = 0)

pr31u <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="late_response_up") %>%
    dplyr::select(gene_id),  
  full_group = "late_response_up",                   
  contrast = "Base",                
  logFC = 0)

pr31d <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="late_response_down") %>%
    dplyr::select(gene_id),  
  full_group = "late_response_down",                   
  contrast = "Base",                
  logFC = 0)

non_significant <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(group == "non_significant") %>%
    dplyr::select(gene_id),  
  full_group = "non_significant_none",                   
  contrast = "Base",                
  logFC = 0)

classify_df_long_temp <- classify_df_long %>%
  dplyr::select(gene_id, full_group, contrast, logFC)

classify_df_long_base0 <- rbind(classify_df_long_temp, pu, pd,
                                eu, ed, pr7u, pr7d,
                                pr31u, pr31d, ru, rd)
table(classify_df_long_base0$full_group)


classify_df_long_base0_full <- rbind(classify_df_long_temp, pu, pd,
                                eu, ed, pr7u, pr7d,
                                pr31u, pr31d, ru, rd, non_significant)
classify_df_long_base0_full <- classify_df_long_base0_full %>% mutate(full_group = case_when(full_group == "transitory_F7_F31_none" ~ "non_significant_none", TRUE ~ full_group))

table(classify_df_long_base0_full$full_group)


```

```{r}

# Plotting: Dotplot + Lineplot
classify_df_long_base0$full_group <- factor(classify_df_long_base0$full_group,
                                       levels = c("plateau_up", "plateau_down",
                                                  "monotonic_up", "monotonic_down",
                                                  "late_response_up", "late_response_down",
                                                  "incomplete_reversed_up", "incomplete_reversed_down",
                                                  "complete_reversed_up", "complete_reversed_down"))

classify_df_long_base0$contrast <- factor(classify_df_long_base0$contrast,
                                          levels = c("Base", "logFC_F7","logFC_F31"))

##
classify_df_long_base0 <- classify_df_long_base0 %>%
  dplyr::mutate(generation = case_when(contrast == "Base"~ 0,
                                       contrast == "logFC_F7"~ 7,
                                       contrast == "logFC_F31"~ 31))

# Include group:
classify_df_long_base0_full <- classify_df_long_base0_full %>%
  mutate(group = case_when(grepl("plateau", full_group) ~ "plateau",
                           grepl("monotonic", full_group) ~ "monotonic",
                          grepl("incomplete_reversed_", full_group) ~ "incomplete_reversed",
                          grepl("complete", full_group) ~ "complete_reversed",
                          grepl("late_response", full_group) ~ "late_response",
                          grepl("non_significant", full_group) ~ "non_significant"))

classify_df_long_base0_full <- classify_df_long_base0_full %>%
  dplyr::mutate(generation = case_when(contrast == "Base"~ 0,
                                       contrast == "logFC_F7"~ 7,
                                       contrast == "logFC_F31"~ 31))

# Calculate median and confidence intervals
summary_data <- classify_df_long_base0_full %>%
  group_by(generation, group) %>%
  summarise(
    mean_value = mean(abs(logFC)),
    ci_lower = quantile(abs(logFC), 0.25),
    ci_upper = quantile(abs(logFC), 0.75),
    .groups = 'drop')

# Include number of DGEs to plot size:
#summary_data$nb_DEGs <- c(710, 337, 777, 417, 3843, 4113,
                          #710, 337, 777, 417, 3843, 4113,
                          #710, 337, 777, 417, 3843, 4113)

summary_data$group <- factor(summary_data$group,
                             levels = c("non_significant",
                                        "plateau",
                                "monotonic",
                                "late_response",
                               "incomplete_reversed",
                               "complete_reversed"))
# Plotting:

ggplot(summary_data, aes(x = as.numeric(generation),
                                 y = abs(mean_value),
                                 color = group)) +
  #geom_line(aes(size = nb_DEGs), alpha = 3) + 
  geom_line(size=3) + 
  #scale_size_manual(values = c(plateau = 7, monotonic = 2,
                               #late_response = 3,
                               #incomplete_reversed = 1,
                               #complete_reversed = 3,
                               #non_significant = 7)) +
  scale_color_manual(values = c("#f0f0f0",color_plateau,
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed),
                     labels = c(non_significant = "Non-significant",
                                plateau = "Plateau",
                                monotonic = "Monotonic",
                                late_response = "Late-response",
                                complete_reversed = "Complete-reverse",
                                incomplete_reversed = "Incomplete-reverse"),
                     name="") +  
  theme_classic() +
  theme(
    axis.text = element_text(size = 14, color = "black"),
    strip.background = element_blank(),
    axis.title.y = element_text(size=14),
    axis.title.x = element_text(size=14),
    legend.title = element_text(size = 14),  
    legend.text = element_text(size = 14),  
    axis.line = element_line(color = "black"),  
    axis.ticks = element_line(color = "black")) +
  xlab("Generation") +
  ylab(bquote(Mean~expression~change~Abs.~log[2]*FC)) +
  coord_cartesian(ylim = c(0, 1)) +
  theme(legend.position = "right") +
  scale_x_continuous(breaks = c(0, 7, 31),
                     labels = c(0,7,31))

# Save plot:
#ggsave("output_files/plots/correlation_plots_and_trajectories/mean_logFC_trajectories.svg", last_plot())

```
## Plot scatter plots:
```{r}
## Plot 3 groups with similar x and y axis:

classify_df %>% dplyr::filter(group %in% c("plateau",
                                           "monotonic",
                                           "incomplete_reversed",
                                           "complete_reversed",
                                           "late_response")) %>% 
  ggplot(aes(x = logFC_F7, y = logFC_F31, colour = group)) + 
  geom_point(size=2, shape=16, alpha=0.5) +
  xlab(bquote(log[2]*FC~Gen~7)) + 
  ylab(bquote(log[2]*FC~Gen~31)) + 
  theme_light() + 
  #coord_fixed() +
# Add ablines
  geom_abline(intercept = 0, slope = 0, linetype = "dashed", color = "grey70") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey70") +
  geom_abline(intercept = 0, slope = -1, linetype = "dashed", color = "grey70") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey70")+
  scale_color_manual(values = c("plateau" = color_plateau,
                                "monotonic" = color_monotonic,
                                "incomplete_reversed" = color_incomplete_reversed,
                                "complete_reversed" = color_complete_reversed,
                                "late_response" = color_late_response)) +
  guides(color = guide_legend(override.aes = list(size = 5))) + 
  guides(color = guide_legend(override.aes = list(size = 5))) +
  theme_linedraw() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 16),  
        axis.title = element_text(size = 16),  
        axis.ticks = element_line(size = 1),
        panel.border = element_rect(color = "black", fill = NA, size = 1))  +
  scale_x_continuous(breaks = c(-8, -4, 0, 4, 8), limits = c(-8, 8)) +
  scale_y_continuous(breaks = c(-8, -4, 0, 4, 8), limits = c(-8, 8)) +
  facet_wrap(~ group, nrow=2)

```
# Summary:
```{r}
table(classify_df$group)

# Total DEGs
total_DEGs <- nrow(classify_df %>% dplyr::filter(!group %in% c("non_significant", "transitory_F7_F31")))

# Number of plateau genes:
plateau_DEGs <- nrow(classify_df %>% dplyr::filter(group == "plateau"))
# Proportion plateau:
prop_plateau <- plateau_DEGs / total_DEGs * 100

# Number of monotonic genes:
monotonic_DEGs <- nrow(classify_df %>% dplyr::filter(group == "monotonic"))
# Proportion monotonic:
prop_monotonic <- monotonic_DEGs / total_DEGs * 100

# Number of incomplete reverse genes:
inc_reverse_DEGs <- nrow(classify_df %>% dplyr::filter(group == "incomplete_reversed"))
# Proportion monotonic:
prop_inc_reverse <- inc_reverse_DEGs / total_DEGs * 100

# Number of complete reverse genes:
c_reverse_DEGs <- nrow(classify_df %>% dplyr::filter(group == "complete_reversed"))
# Proportion monotonic:
prop_c_reverse <- c_reverse_DEGs / total_DEGs * 100

# Number of complete reverse genes:
late_response_DEGs <- nrow(classify_df %>% dplyr::filter(group == "late_response"))
# Proportion monotonic:
prop_late_response <- late_response_DEGs / total_DEGs * 100



# Print summary:
paste("Number of DEGs:", as.character(total_DEGs))

paste("Number of plateau DEGs:", as.character(plateau_DEGs))
paste("Proportion plateau DEGs:", as.character(prop_plateau))

paste("Number of monotonic DEGs:", as.character(monotonic_DEGs))
paste("Proportion monotonic DEGs:", as.character(prop_monotonic))

paste("Number of incomplete reverse DEGs:", as.character(inc_reverse_DEGs))
paste("Proportion incomplete reverse DEGs:", as.character(prop_inc_reverse))

paste("Number of complete reverse DEGs:", as.character(c_reverse_DEGs))
paste("Proportion complete reverse DEGs:", as.character(prop_c_reverse))

paste("Number of late response DEGs:", as.character(late_response_DEGs))
paste("Proportion late response DEGs:", as.character(prop_late_response))

```
# Export classify_trajectories_df:
```{r}
export_df <- classify_df
#write_csv(export_df, "input_files/classify_trajectories_df.csv")
#write_csv(export_df, "out_files/classify_trajectories_df.csv")

```
# Fig 3 A - Pie chart
```{r}

# remove non_significant genes:
filt_df <- classify_df %>% dplyr::filter(!group %in% c("non_significant")) %>% droplevels()


manual_palette = c(color_plateau,
                   color_monotonic,
                   color_incomplete_reversed,
                   color_complete_reversed,
                   color_late_response)

# Donut chart
donutchart <- lessR::PieChart(group,
                       data = filt_df,
                       main = NULL,
                       color="white",
                       lty="solid",
                       labels_size = 1.3,
                       lwd=3,
                       fill = manual_palette)



```
# Part 2: use PCA to classify trajectories (overall model DEGs)
# Create metadata:
NOTE: TB stands for "Trial Big". Trial Big (TB) is the sample name we give to the
evolved large populations (N=100,000) in high-protein diet (trial diet).
```{r}

# Get count table after filtering low expression:
count_all_genes <- count_table_filt
metadata <- as_tibble(colnames(count_all_genes))
# Create group_name
# Common Garden Experiments (CGE = base population at F0, CGE2_1 = Trial Big at F7 and CGE3_1 = Trial Big at F31)
metadata <- metadata %>% 
     mutate(group_name = case_when(
      grepl("CGE1", value) & grepl("rep_B", value) ~"B",
      grepl("CGE2_1", value) & 
      grepl("rep_31_|rep_32_|rep_33_|rep_34_|rep_35_|rep_36_", value) ~"2_1_TB",       
      grepl("CGE3_1", value) & 
      grepl("rep_31_|rep_32_|rep_33_|rep_34_|rep_35_|rep_36_", value) ~"3_1_TB"))

metadata <- metadata %>% dplyr::rename(sample = value)

# Add a column for generation:
metadata <- metadata %>% 
  mutate(generation = case_when(group_name == "B" ~ "gen0",
                                group_name == "2_1_TB" ~ "gen7",
                                group_name == "3_1_TB" ~ "gen31"))

# Add a column for replicate:
metadata$rep <- sub(".*rep_(.*)", "\\1", metadata$sample)
# Relabel replicates as 01, 02 etc:
metadata$rep <- sub("^3", "0", metadata$rep)
# Check the number of replicates per group:
(table(metadata$group_name))

```
## Subset count tables for each group:
```{r}
plateau_DEGs <- classify_df %>% dplyr::filter(group == "plateau") %>% dplyr::select(gene_id)
monotonic_DEGs <- classify_df %>% dplyr::filter(group == "monotonic") %>% dplyr::select(gene_id)
late_response_DEGs <- classify_df %>% dplyr::filter(group == "late_response") %>% dplyr::select(gene_id)
complete_reversed_DEGs <- classify_df %>% dplyr::filter(group == "complete_reversed") %>% dplyr::select(gene_id)
incomplete_reversed_DEGs <- classify_df %>% dplyr::filter(group == "incomplete_reversed") %>% dplyr::select(gene_id)

plateau_count_table <- count_table_filt[rownames(count_table_filt) %in% plateau_DEGs$gene_id, ]
monotonic_count_table <- count_table_filt[rownames(count_table_filt) %in% monotonic_DEGs$gene_id, ]
late_response_count_table <- count_table_filt[rownames(count_table_filt) %in% late_response_DEGs$gene_id, ]
complete_reversed_count_table <- count_table_filt[rownames(count_table_filt) %in% complete_reversed_DEGs$gene_id, ]
incomplete_reversed_count_table <- count_table_filt[rownames(count_table_filt) %in% incomplete_reversed_DEGs$gene_id, ]

```
## Generate DGElist with gene counts:
```{r}
y_plateau <- DGEList(counts = plateau_count_table, group = metadata$group_name) # Group 
#name is assigned correctly because low_genes_filtered and group_names data-sets 
#have the rows in the same order.
y_plateau <- normLibSizes(y_plateau) # scaling factors computed using the TMM method  
#to convert the resulting library sizes to effective library sizes.

##
y_monotonic <- DGEList(counts = monotonic_count_table, group = metadata$group_name) 
y_monotonic <- normLibSizes(y_monotonic)

##

y_late_response <- DGEList(counts = late_response_count_table, group = metadata$group_name) 
y_late_response <- normLibSizes(y_late_response)

##

y_complete_reversed <- DGEList(counts = complete_reversed_count_table, group = metadata$group_name) 
y_complete_reversed <- normLibSizes(y_complete_reversed)

##

y_incomplete_reversed <- DGEList(counts = incomplete_reversed_count_table, group = metadata$group_name) 
y_incomplete_reversed <- normLibSizes(y_incomplete_reversed)

```

### Plateau
The CPM values are scaled and centered prior to PCA.
```{r}
#  41 samples:
y_plateau_B_TB <- y_plateau[, (y_plateau$samples$group %in% c("B","2_1_TB", "3_1_TB"))]

#PCA
pca <- y_plateau_B_TB %>% 
  cpm(log = TRUE) %>%
    t() %>%
    prcomp(center = TRUE, scale. = TRUE)
#summary(pca)$importance 

pcaPlot <- as.data.frame(pca$x)
# Label the generation group:
pcaPlot$generation <- metadata$generation[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(generation, .before = PC1)
# Label the replicate:
pcaPlot$rep <- metadata$rep[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(rep, .after = generation)
# Compute variance explained:
ve <- pca$sdev^2 / sum(pca$sdev^2)
# Change generation labels:
pcaPlot <- pcaPlot %>% dplyr::mutate(gen = case_when(generation == "gen0" ~ "Gen 0",
                                                     generation == "gen7" ~ "Gen 7",
                                                     generation == "gen31" ~ "Gen 31"))
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
pcaPlot$gen <- factor(pcaPlot$gen, c("Gen 0","Gen 7", "Gen 31"))

# Convert rownames into a column.
pcaPlot <- cbind(sample = rownames(pcaPlot), pcaPlot)
rownames(pcaPlot) <- 1:nrow(pcaPlot)

# create pcaPlot for Permanova test:
pcaPlot_plateau <- pcaPlot

list_a <- c("PC2")
list_b <- c(2)

for (i in list_a){
  p <- plot_pca(dat = pcaPlot, aesx = "PC1", aesy = i, 
         color = "gen", 
         mytitle = "",
         scale_color_set = scale_color_manual(
        values = c("orange", color_plateau, color_plateau)), 
         shape_set = c(16,0,15),  
         PCX = 1, 
         PCY = list_b[which(list_a == i)])
  print(p)

}


p <- p + ggtitle("Plateau") +
  theme(plot.title = element_text(hjust = 0.5,
                                  family = "Times-Bold",
                                  size = 20))

p


```
### Monotonic
```{r}
#  41 samples:
y_monotonic_B_TB <- y_monotonic[, (y_monotonic$samples$group %in% c("B","2_1_TB", "3_1_TB"))]

#PCA
pca <- y_monotonic_B_TB %>% 
  cpm(log = TRUE) %>%
    t() %>%
    prcomp(center = TRUE, scale. = TRUE)
#summary(pca)$importance 

pcaPlot <- as.data.frame(pca$x)
# Label the generation group:
pcaPlot$generation <- metadata$generation[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(generation, .before = PC1)
# Label the replicate:
pcaPlot$rep <- metadata$rep[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(rep, .after = generation)
# Compute variance explained:
ve <- pca$sdev^2 / sum(pca$sdev^2)
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
# Convert rownames into a column.
pcaPlot <- cbind(sample = rownames(pcaPlot), pcaPlot)
rownames(pcaPlot) <- 1:nrow(pcaPlot)
# Change generation labels:
pcaPlot <- pcaPlot %>% dplyr::mutate(gen = case_when(generation == "gen0" ~ "Gen 0",
                                                     generation == "gen7" ~ "Gen 7",
                                                     generation == "gen31" ~ "Gen 31"))
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
pcaPlot$gen <- factor(pcaPlot$gen, c("Gen 0","Gen 7", "Gen 31"))


# Create pcaPlot for Permanova test:
pcaPlot_monotonic <- pcaPlot

list_a <- c("PC2")
list_b <- c(2)

for (i in list_a){
  m <- plot_pca(dat = pcaPlot, aesx = "PC1", aesy = i, 
         color = "gen", 
         mytitle = "",
         scale_color_set = scale_color_manual(
          values = c("orange",color_monotonic,color_monotonic)), 
         shape_set = c(16,0,15),  
         PCX = 1, 
         PCY = list_b[which(list_a == i)])
  print(m)

}

m <- m + ggtitle("Monotonic") +
  theme(plot.title = element_text(hjust = 0.5,
                                  family = "Times-Bold", size = 20))

m


```
### Late-response
```{r}
#  41 samples:
y_late_response_B_TB <- y_late_response[, (y_late_response$samples$group %in% c("B","2_1_TB", "3_1_TB"))]

#PCA
pca <- y_late_response_B_TB %>% 
  cpm(log = TRUE) %>%
    t() %>%
    prcomp(center = TRUE, scale. = TRUE)
#summary(pca)$importance 

pcaPlot <- as.data.frame(pca$x)
# Label the generation group:
pcaPlot$generation <- metadata$generation[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(generation, .before = PC1)
# Label the replicate:
pcaPlot$rep <- metadata$rep[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(rep, .after = generation)
# Compute variance explained:
ve <- pca$sdev^2 / sum(pca$sdev^2)
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
# Convert rownames into a column.
pcaPlot <- cbind(sample = rownames(pcaPlot), pcaPlot)
rownames(pcaPlot) <- 1:nrow(pcaPlot)
# Change generation labels:
pcaPlot <- pcaPlot %>% dplyr::mutate(gen = case_when(generation == "gen0" ~ "Gen 0",
                                                     generation == "gen7" ~ "Gen 7",
                                                     generation == "gen31" ~ "Gen 31"))
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
pcaPlot$gen <- factor(pcaPlot$gen, c("Gen 0","Gen 7", "Gen 31"))

# Create pcaPlot for Permanova test:
pcaPlot_late_response <- pcaPlot

list_a <- c("PC2")
list_b <- c(2)

for (i in list_a){
  l <- plot_pca(dat = pcaPlot, aesx = "PC1", aesy = i, 
         color = "gen", 
         mytitle = "",
         scale_color_set = scale_color_manual(
          values = c("orange",color_late_response, color_late_response)), 
         shape_set = c(16,0,15),  
         PCX = 1, 
         PCY = list_b[which(list_a == i)])
  print(l)

}

l <- l + ggtitle("Late-response") + theme(plot.title = element_text(hjust = 0.5,
                                                              family = "Times-Bold", size = 20))

l

```
### Complete-reverse
```{r}
#  41 samples:
y_complete_reversed_B_TB <- y_complete_reversed[, (y_complete_reversed$samples$group %in% c("B","2_1_TB", "3_1_TB"))]

#PCA
pca <- y_complete_reversed_B_TB %>% 
  cpm(log = TRUE) %>%
    t() %>%
    prcomp(center = TRUE, scale. = TRUE)
#summary(pca)$importance 

pcaPlot <- as.data.frame(pca$x)
# Label the generation group:
pcaPlot$generation <- metadata$generation[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(generation, .before = PC1)
# Label the replicate:
pcaPlot$rep <- metadata$rep[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(rep, .after = generation)
# Compute variance explained:
ve <- pca$sdev^2 / sum(pca$sdev^2)
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
# Convert rownames into a column.
pcaPlot <- cbind(sample = rownames(pcaPlot), pcaPlot)
rownames(pcaPlot) <- 1:nrow(pcaPlot)
# Change generation labels:
pcaPlot <- pcaPlot %>% dplyr::mutate(gen = case_when(generation == "gen0" ~ "Gen 0",
                                                     generation == "gen7" ~ "Gen 7",
                                                     generation == "gen31" ~ "Gen 31"))
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
pcaPlot$gen <- factor(pcaPlot$gen, c("Gen 0","Gen 7", "Gen 31"))

# Create pcaPlot for Permanova test:
pcaPlot_complete_reverse <- pcaPlot

list_a <- c("PC2")
list_b <- c(2)

for (i in list_a){
  c <- plot_pca(dat = pcaPlot, aesx = "PC1", aesy = i, 
         color = "gen", 
         mytitle = "",
         scale_color_set = scale_color_manual(
          values = c("orange", color_complete_reversed, color_complete_reversed)), 
         shape_set = c(16,0,15),  
         PCX = 1, 
         PCY = list_b[which(list_a == i)])
  print(c)

}

c <- c + ggtitle("Complete-reverse") +
  theme(plot.title = element_text(hjust = 0.5,
                                  family = "Times-Bold",
                                  size = 20))

c


```
### Incomplete-reverse
```{r}
#  41 samples:
y_incomplete_reversed_B_TB <- y_incomplete_reversed[, (y_incomplete_reversed$samples$group %in% c("B","2_1_TB", "3_1_TB"))]

#PCA
pca <- y_incomplete_reversed_B_TB %>% 
  cpm(log = TRUE) %>%
    t() %>%
    prcomp(center = TRUE, scale. = TRUE)
#summary(pca)$importance 

pcaPlot <- as.data.frame(pca$x)
# Label the generation group:
pcaPlot$generation <- metadata$generation[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(generation, .before = PC1)
# Label the replicate:
pcaPlot$rep <- metadata$rep[match(rownames(pcaPlot), metadata$sample)]
pcaPlot <- pcaPlot %>% relocate(rep, .after = generation)
# Compute variance explained:
ve <- pca$sdev^2 / sum(pca$sdev^2)
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
# Convert rownames into a column.
pcaPlot <- cbind(sample = rownames(pcaPlot), pcaPlot)
rownames(pcaPlot) <- 1:nrow(pcaPlot)
# Change generation labels:
pcaPlot <- pcaPlot %>% dplyr::mutate(gen = case_when(generation == "gen0" ~ "Gen 0",
                                                     generation == "gen7" ~ "Gen 7",
                                                     generation == "gen31" ~ "Gen 31"))
# Reorder the levels of generation
pcaPlot$generation <- factor(pcaPlot$generation, c("gen0","gen7", "gen31"))
pcaPlot$gen <- factor(pcaPlot$gen, c("Gen 0","Gen 7", "Gen 31"))

# Create pcaPlot for Permanova test:
pcaPlot_incomplete_reverse <- pcaPlot

list_a <- c("PC2")
list_b <- c(2)

for (i in list_a){
  i <- plot_pca(dat = pcaPlot, aesx = "PC1", aesy = i, 
         color = "gen", 
         mytitle = "",
         scale_color_set = scale_color_manual(
          values = c("orange",color_incomplete_reversed,color_incomplete_reversed)), 
         shape_set = c(16,0,15),  
         PCX = 1, 
         PCY = list_b[which(list_a == i)])
  print(i)

}


i <- i + ggtitle("Incomplete-reverse") + theme(plot.title = element_text(hjust = 0.5,
                                                              family = "Times-Bold", size = 20))

i

```
## Fig 3 B - Plot PCAs all groups
```{r}
combined_plots <- l + m + i + c + p +  
  plot_layout(ncol = 2)

combined_plots <- p + plot_spacer() + l + m + i + c +  
  plot_layout(ncol = 2)
  
combined_plots

# Save the plot as a PNG file in the 'plots_folder'
#ggsave(plot = last_plot(), "output_files/plots/PCA_per_group.svg", width = 180,height = 220,units = "mm", dpi = 300)

```

## PERMANOVA test:

Permutational Multivariate Analysis of Variance Using Distance Matrices:
Analysis of variance using distance matrices — for partitioning distance
matrices among sources of variation and fitting linear models
(e.g., factors, polynomial regression) to distance matrices;
uses a permutation test with pseudo-F ratios.

PERMANOVA, often implemented through the adonis() function in the
vegan package in R, is a non-parametric test used to compare the centroids
(average location) of clusters in multivariate space.

LOOK HERE: https://github.com/vari-bbc/bbcRNA/issues/3
```{r}
## Obnibus test ##
## Plateau F0, F7 and F31:
meta <- pcaPlot_plateau %>% dplyr::select(generation)
# Subset PC1 and PC2:
pcs <-  pcaPlot_plateau[, 4]
## # Run PERMANOVA on PC1 and PC2 scores:
perm_plateau <- adonis2(pcs ~ meta$generation, method="eu", permutations = 9999)
perm_plateau

## Post hoc pairwise tests ##
## Implement a function:
# Define the function
pairwise_permanova <- function(data, gen_pair, pc_columns = 4:5, method = "euclidean", permutations = 9999) {
  # Subset the metadata for the specified generations
  meta <- data %>%
    filter(generation %in% gen_pair) %>%
    select(generation)
  
  # Subset the PCA scores for the specified generations and PCs
  pcs <- data %>%
    filter(generation %in% gen_pair) %>%
    select(all_of(pc_columns))
  
  # Run PERMANOVA
  perm_result <- adonis2(pcs ~ meta$generation, method = method, permutations = permutations)
  
  # Return the result
  return(perm_result)
}

```
## Perform tests:
```{r}

# Set common permutations number for all permanova tests:
permu_nb <- 10000


## Plateau:
perm_plateau_F0F7 <- pairwise_permanova(data = pcaPlot_plateau, pc_columns = 4:5, gen_pair = c("gen0", "gen7"), method = "euclidean", permutations = permu_nb)
perm_plateau_F0F31 <- pairwise_permanova(data = pcaPlot_plateau, pc_columns = 4:5, gen_pair = c("gen0", "gen31"), method = "euclidean", permutations = permu_nb)
perm_plateau_F7F31 <- pairwise_permanova(data = pcaPlot_plateau, pc_columns = 4:5, gen_pair = c("gen7", "gen31"), method = "euclidean", permutations = permu_nb)
# Create a results data-set:
contrast <- c("F0vsF7","F0vsF31","F7vsF31")
p_value <- c(perm_plateau_F0F7$`Pr(>F)`[1], perm_plateau_F0F31$`Pr(>F)`[1], perm_plateau_F7F31$`Pr(>F)`[1])
group <- c("plateau","plateau","plateau")
perm_plateau_results <- data.frame(group, contrast, p_value)
# Multiple-test correction:
perm_plateau_results$padj_fdr <- p.adjust(perm_plateau_results$p_value, method = "fdr", n = 3)

## Late response
perm_late_response_F0F7 <- pairwise_permanova(data = pcaPlot_late_response, pc_columns = 4:5, gen_pair = c("gen0", "gen7"), method = "euclidean", permutations = permu_nb)
perm_late_response_F0F31 <- pairwise_permanova(data = pcaPlot_late_response, pc_columns = 4:5, gen_pair = c("gen0", "gen31"), method = "euclidean", permutations = permu_nb)
perm_late_response_F7F31 <- pairwise_permanova(data = pcaPlot_late_response, pc_columns = 4:5, gen_pair = c("gen7", "gen31"), method = "euclidean", permutations = permu_nb)
# Create a results data-set:
contrast <- c("F0vsF7","F0vsF31","F7vsF31")
p_value <- c(perm_late_response_F0F7$`Pr(>F)`[1], perm_late_response_F0F31$`Pr(>F)`[1], perm_late_response_F7F31$`Pr(>F)`[1])
group <- c("late-response","late-response","late-response")
perm_late_response_results <- data.frame(group, contrast, p_value)
# Multiple-test correction:
perm_late_response_results$padj_fdr <- p.adjust(perm_late_response_results$p_value, method = "fdr", n = 3)

## Monotonic
perm_monotonic_F0F7 <- pairwise_permanova(data = pcaPlot_monotonic, gen_pair = c("gen0", "gen7"), method = "euclidean", permutations = permu_nb)
perm_monotonic_F0F31 <- pairwise_permanova(data = pcaPlot_monotonic, gen_pair = c("gen0", "gen31"), method = "euclidean", permutations = permu_nb)
perm_monotonic_F7F31 <- pairwise_permanova(data = pcaPlot_monotonic, gen_pair = c("gen7", "gen31"), method = "euclidean", permutations = permu_nb)
# Create a results data-set:
contrast <- c("F0vsF7","F0vsF31","F7vsF31")
p_value <- c(perm_monotonic_F0F7$`Pr(>F)`[1], perm_monotonic_F0F31$`Pr(>F)`[1], perm_monotonic_F7F31$`Pr(>F)`[1])
group <- c("monotonic","monotonic","monotonic")
perm_monotonic_results <- data.frame(group, contrast, p_value)
# Multiple-test correction:
perm_monotonic_results$padj_fdr <- p.adjust(perm_monotonic_results$p_value, method = "fdr", n = 3)

## Complete-reverse
perm_complete_reverse_F0F7 <- pairwise_permanova(data = pcaPlot_complete_reverse, pc_columns = 4:5, gen_pair = c("gen0", "gen7"), method = "euclidean", permutations = permu_nb)
perm_complete_reverse_F0F31 <- pairwise_permanova(data = pcaPlot_complete_reverse, pc_columns = 4:5, gen_pair = c("gen0", "gen31"), method = "euclidean", permutations = permu_nb)
perm_complete_reverse_F7F31 <- pairwise_permanova(data = pcaPlot_complete_reverse, pc_columns = 4:5, gen_pair = c("gen7", "gen31"), method = "euclidean", permutations = permu_nb)
# Create a results data-set:
contrast <- c("F0vsF7","F0vsF31","F7vsF31")
p_value <- c(perm_complete_reverse_F0F7$`Pr(>F)`[1], perm_complete_reverse_F0F31$`Pr(>F)`[1], perm_complete_reverse_F7F31$`Pr(>F)`[1])
group <- c("complete-reverse","complete-reverse","complete-reverse")
perm_complete_reverse_results <- data.frame(group, contrast, p_value)
# Multiple-test correction:
perm_complete_reverse_results$padj_fdr <- p.adjust(perm_complete_reverse_results$p_value, method = "fdr", n = 3)

## Incomplete-reverse
perm_incomplete_reverse_F0F7 <- pairwise_permanova(data = pcaPlot_incomplete_reverse, pc_columns = 4:5, gen_pair = c("gen0", "gen7"), method = "euclidean", permutations = permu_nb)
perm_incomplete_reverse_F0F31 <- pairwise_permanova(data = pcaPlot_incomplete_reverse, pc_columns = 4:5, gen_pair = c("gen0", "gen31"), method = "euclidean", permutations = permu_nb)
perm_incomplete_reverse_F7F31 <- pairwise_permanova(data = pcaPlot_incomplete_reverse, pc_columns = 4:5, gen_pair = c("gen7", "gen31"), method = "euclidean", permutations = permu_nb)
# Create a results data-set:
contrast <- c("F0vsF7","F0vsF31","F7vsF31")
p_value <- c(perm_incomplete_reverse_F0F7$`Pr(>F)`[1], perm_incomplete_reverse_F0F31$`Pr(>F)`[1], perm_incomplete_reverse_F7F31$`Pr(>F)`[1])
group <- c("incomplete-reverse","incomplete-reverse","incomplete-reverse")
perm_incomplete_reverse_results <- data.frame(group, contrast, p_value)
# Multiple-test correction:
perm_incomplete_reverse_results$padj_fdr <- p.adjust(perm_incomplete_reverse_results$p_value, method = "fdr", n = 3)

# Combined dataset:
permanova_all_results <- rbind(perm_plateau_results, perm_late_response_results, perm_monotonic_results, perm_complete_reverse_results, perm_incomplete_reverse_results)

```

--- END ---

