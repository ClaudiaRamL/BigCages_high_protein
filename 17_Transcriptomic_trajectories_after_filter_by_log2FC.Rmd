---
title: "High-Protein BigCages - full pipeline after filtering logFC"
Author: "Claudia Ramirez-lanzas"
Date: "25/02/2025"
---

# Load libraries:
```{r}
library("readxl") 
library("writexl") 
library("tidyverse") 

# Plotting
library("khroma") # plotting colour blind safe
library("ggplot2") 
library("patchwork") # to combine plots
library("scales") # labeling in percentages
library("ggbreak") # Make custom scales with breaks
library("svglite") 
library("egg")
library("pheatmap") 
library("RColorBrewer") 
library("scatterplot3d") 
library("lessR") # Pie charts
library("UpSetR") # UpSets plots


# Statistical operations and data analysis:
library("car")
library("edgeR") # To create object for PCA
library("vegan") # to perform permanova test on PCA groups
library("rstatix") 
library("ggpubr") 
library("ggsignif")



```
# Check sessionInfo:
```{r}
sessionInfo()
```
# Set-up colors:
```{r}
bright <- color("bright")
plot_scheme(bright(6), colours = TRUE, names = TRUE, size = 0.9)
#
muted <- color("muted")
plot_scheme(muted(9), colours = TRUE, names = TRUE, size = 0.9)

color_plateau <- muted(9)[2] #"#332288"
color_monotonic <- muted(9)[7] #"#44AA99"
color_late_response <-  "#D4AF37"
color_incomplete_reversed <- muted(9)[9] #"#AA4499"
color_complete_reversed <- muted(9)[5] #"#88CCEE" 
color_shared <- muted(9)[1] #"#CC6677" 

plot_scheme(muted(9)[2], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[7], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[9], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[3], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[5], colours = TRUE, names = TRUE, size = 0.9)
plot_scheme(muted(9)[1], colours = TRUE, names = TRUE, size = 0.9)


```
# # PART 1: Transcriptomic trajectories 

# Import files:
```{r}
DE_overall_results <- read_csv("input_files/DE_overall_results.csv", show_col_types = FALSE)

count_table <- read.delim("input_files/count_table.csv", sep=";")
count_table <- count_table %>% column_to_rownames(var = "gene_id")

```

* DE_overall_results: contains the results of DE analysis using dream model. 
Including 3 contrasts: Base vs F7, Base vs F31 and F7 vs F31. P-values corrected across the 3 contrasts using the fdr method.

* count_table: .csv file  containing the RNA count table
(the output of featureCounts function from subRead).
Each column is a sample and each row a gene.
It contains 5 samples from Base (F0),
18 samples from Big populations at F7 and 18 samples at F31.
The samples are labeled with biological names. 

# Count table after filtering low expression.
Same set of genes used for DE analysis and PCA analysis.
```{r}
#Library size = Total number of fragments (paired ends) mapped to the genome. 
lib_size <- colSums(count_table)
hist(lib_size)
average_library_size <- mean(lib_size) # 10 millions
average_library_size


### Remove lowly expressed genes:
#Set CPM threshold:
CPM_threshold <- 1 

# Create filtered count table:
count_table_filt <- count_table[apply(cpm(count_table), 1, function(x){!(sum(x < CPM_threshold) >= 1)}),] # If there is one sample or more with CPM < threshold then the gene is filtered out. 

# print filtering summary:
paste("all genes:", nrow(count_table))
paste("genes available after filtering:", nrow(count_table_filt))
paste("genes discarded", nrow(count_table) - nrow(count_table_filt))
paste("% genes discarded" , ((nrow(count_table) - nrow(count_table_filt))/nrow(count_table))*100)

```
## Function 1 - Plotting PCAs
```{r}
# PCA without labels:
plot_pca <- function(dat, aesx, aesy, color, mytitle, scale_color_set, shape_set, PCX, PCY) {
  ggplot2::ggplot(data = dat, aes_string(x = aesx, y = aesy, color = color, shape = color)) +
  geom_point(size = 3) + 
  scale_shape_manual(values = shape_set)  +
  scale_color_manual(values = scale_color_set) +
  theme_classic() + 
  theme(
    legend.title = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
      text = element_text(size = 11)) +
  labs(title=mytitle) +
  xlab(paste0(aesx," (",round(ve[PCX]*100,2),"%)")) +
  ylab(paste0(aesy," (",round(ve[PCY]*100,2),"%)")) + 
    scale_color_set +
  theme(axis.text = element_text(size = 12),  
        axis.title = element_text(size = 14),  
        axis.ticks = element_line(size = 1),
        legend.text=element_text(size=14))

}

# PCA labeling the replicates:
plot_pca_label_rep <- function(dat, aesx, aesy, color, mytitle, scale_color_set, shape_set, PCX, PCY) {
  ggplot2::ggplot(data = dat, aes_string(x = aesx, y = aesy, color = color, shape = color)) +
  geom_point(size = 4) + 
    geom_text(aes(label = rep), vjust = -1.5) +
  scale_shape_manual(values = shape_set)  +
  scale_color_manual(values = scale_color_set) +
  theme_classic() + 
  theme(
    legend.title = element_blank(),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
      text = element_text(size = 11)) +
  labs(title=mytitle) +
  xlab(paste0(aesx," (",round(ve[PCX]*100,2),"%)")) +
  ylab(paste0(aesy," (",round(ve[PCY]*100,2),"%)")) + 
    scale_color_set +
  theme(axis.text = element_text(size = 12),  
        axis.title = element_text(size = 14),  
        axis.ticks = element_line(size = 1))  
}

```
## Function 2 - Classify trajectories
```{r}
classify_DEGs <- function(DE_df, alpha_thresh = 0.05, logFC_thresh = 0) {
  

  # Convert the p-value of genes with log2FC < 0.32 into 1 so they become non-significant.
  df <- DE_df %>% #DE_df
  mutate(padj_F7 = case_when(
    abs(logFC_F7) < logFC_thresh ~ 1,
    TRUE ~ padj_F7)) %>%
  mutate(padj_F31 = case_when(
    abs(logFC_F31) < logFC_thresh ~ 1,
    TRUE ~ padj_F31)) #%>%
  #mutate(padj_F7_F31 = case_when(
    #abs(logFC_F7_F31) < logFC_thresh ~ 1,
    #TRUE ~ padj_F7_F31))
  
  # Create empty columns
  df$group <- "NA"
  df$direction <- "NA"
  
    # Define logical conditions:
  non_significant <- df$padj_F7 > alpha_thresh & df$padj_F31 > alpha_thresh & df$padj_F7_F31 > alpha_thresh
  
  plateau_up <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 > alpha_thresh & df$logFC_F7 > 0 & df$logFC_F31 > 0
  
  plateau_down <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 > alpha_thresh & df$logFC_F7 < 0 & df$logFC_F31 < 0
  
  transitory_F7_F31 <- df$padj_F7 > alpha_thresh & df$padj_F31 > alpha_thresh & df$padj_F7_F31 < alpha_thresh
  
  F7_private_up <- df$padj_F7 < alpha_thresh & df$padj_F31 > alpha_thresh & df$logFC_F7 > 0
  
  F7_private_down <- df$padj_F7 < alpha_thresh & df$padj_F31 > alpha_thresh & df$logFC_F7 < 0
  
  F31_private_up <- df$padj_F7 > alpha_thresh & df$padj_F31 < alpha_thresh & df$logFC_F31 > 0
  
  monotonic_up <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 < alpha_thresh & (df$logFC_F7 > 0 & df$logFC_F31 > 0) & df$logFC_F7 < df$logFC_F31
  
  reversed_up <- df$padj_F7_F31 < alpha_thresh & df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & (df$logFC_F7 > 0 & df$logFC_F7 > df$logFC_F31)
  
  F31_private_down <- df$padj_F7 > alpha_thresh & df$padj_F31 < alpha_thresh & df$logFC_F31 < 0
  
  monotonic_down <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 < alpha_thresh & (df$logFC_F7 < 0 & df$logFC_F31 < 0) & df$logFC_F7 > df$logFC_F31
  
  reversed_down <- df$padj_F7 < alpha_thresh & df$padj_F31 < alpha_thresh & df$padj_F7_F31 < alpha_thresh & (df$logFC_F7 < 0 & df$logFC_F7 < df$logFC_F31)
  
  # Apply classifications:
  df$group[non_significant] <- "non_significant"
  df$direction[non_significant] <- "none"
  df$group[plateau_up] <- "plateau"
  df$direction[plateau_up] <- "up"
  df$group[plateau_down] <- "plateau"
  df$direction[plateau_down] <- "down"
  df$group[transitory_F7_F31] <- "non_significant"
  df$direction[transitory_F7_F31] <- "none"
  df$group[F7_private_up] <- "complete_reversed"
  df$direction[F7_private_up] <- "up"
  df$group[F7_private_down] <- "complete_reversed"
  df$direction[F7_private_down] <- "down"
  df$group[F31_private_up] <- "late_response"
  df$direction[F31_private_up] <- "up"
  df$group[monotonic_up] <- "monotonic"
  df$direction[monotonic_up] <- "up"
  df$group[reversed_up] <- "incomplete_reversed"
  df$direction[reversed_up] <- "up"
  df$group[F31_private_down] <- "late_response"
  df$direction[F31_private_down] <- "down"
  df$group[monotonic_down] <- "monotonic"
  df$direction[monotonic_down] <- "down"
  df$group[reversed_down] <- "incomplete_reversed"
  df$direction[reversed_down] <- "down"
  
  return(df)
 
  }

```

# # #### Correlation of transcriptomic response

Filter genes by absolute log2FC > 0.32:

A log2FC of 0.32 correspond to ~0.25 fold change.
So we will keep genes which changed at least 0.25% compared to the base population.

Since we need all genes to remain in the dataset,
I will convert the p-value of genes with log2FC < 0.32 into 10
so they become non-significant.
```{r}
DE_overall_results$padj_fdr <- as.numeric(DE_overall_results$padj_fdr)
DE_overall_results$logFC <- as.numeric(DE_overall_results$logFC)

# Convert all genes with log2FC < 0.32 into non-significant.
DE_overall_results_filt_log2FC <- DE_overall_results %>%
  mutate(padj_fdr = case_when(
    abs(logFC) < 0.32 ~ 1,
    TRUE ~ padj_fdr))
  
```
Plot the correlation of transcriptomic response (log2FC) between F7 and F31.
# Prepare dataset:
```{r}
# Check No of transitory genes: contrast "dream_F31_F7":
nrow(DE_overall_results_filt_log2FC %>% dplyr::filter(contrast == "dream_F31_F7" & padj_fdr < 0.05))

# Remove the contrast "dream_F31_F7":
DE_results_filt <- DE_overall_results_filt_log2FC %>% dplyr::filter(contrast != "dream_F31_F7") 

# Keep only needed columns:
DE_results_short <- DE_results_filt %>% 
  dplyr::select("gene_id", "logFC", "padj_fdr", "contrast")

# Change column names:
colnames(DE_results_short) <- c("gene_id", "logFC", "padj", "contrast")

# From wide to long:
DE_results_wide <- DE_results_short %>%
  pivot_wider(
    names_from = contrast,
    values_from = c(logFC, padj))

colnames(DE_results_wide) <- c("gene_id",
                              "logFCF7", 
                              "logFCF31",
                              "padjF7",
                              "padjF31")

```
# Classify genes - 3 groups
shared: DEGs at both base vs F7 and base vs F31
F7_specific: DEGs only at base vs F7
F31_specific: DEGs only at base vs F31
not_sig: not significant change when compared to base.

```{r}
DE_results_wide <- DE_results_wide %>% 
  dplyr::mutate(label = case_when(
  padjF7 < 0.05  & padjF31 < 0.05 ~ "shared",
  padjF7 < 0.05  & padjF31 >= 0.05 ~ "F7_specific",
  padjF7 >= 0.05  & padjF31 < 0.05 ~ "F31_specific",
  padjF7 >=  0.05 & padjF31 >=  0.05 ~ "not_sig",
  TRUE ~ "NA"))

# Relevel contrasts:
DE_results_wide$label <- factor(DE_results_wide$label,
                                levels = c("not_sig",
                                           "F7_specific",
                                           "F31_specific",
                                           "shared"))

# Check No DEGs in each group:
table(DE_results_wide$label)
# Total number of DEGs between Base and evolved populations at F7 and F31:
nrow(DE_results_wide %>% dplyr::filter(label %in% c("shared", "F7_specific", "F31_specific")))

# Plotting: 
plot_df <- as.data.frame(table(DE_results_wide$label))
plot_df %>%
  ggplot(aes( x = Var1, y = Freq)) + 
  geom_bar(stat = "identity") + 
  ggtitle("Summary of DE analysis") +
  xlab("contrast") +
  ylab("No DEGs") +
  theme_classic()

```
# Figure 2:
```{r}

plot_df <- DE_results_wide
# Relabel groups:

plot_df <- plot_df %>%
  dplyr::mutate(label = case_when(label == "F7_specific" ~ "complete_reversed",
                                  label == "F31_specific" ~ "late_response",
                                  label == "shared" ~ "shared", TRUE ~ label))
# Create variables for legend:
shared_nb <- nrow(plot_df %>% dplyr::filter(label == "shared"))
not_sig_nb <- nrow(plot_df %>% dplyr::filter(label == "not_sig"))
complete_reversed_nb <- nrow(plot_df %>% dplyr::filter(label == "complete_reversed"))
late_response_nb <- nrow(plot_df %>% dplyr::filter(label == "late_response"))

# Relevel label:
plot_df$label <- factor(plot_df$label, levels = c("not_sig",
                                                  "shared",
                                                  "complete_reversed",
                                                  "late_response" ))


# Plotting: 
plot_df %>% 
  arrange(label) %>% 
  ggplot(aes(x = logFCF7, y = logFCF31, colour = label)) + 
  geom_point(size=2, shape=16) +
  xlim(c(-6, 6)) +
  ylim(c(-6, 6)) +
  xlab(bquote(log[2]*FC~Gen~7)) + 
  ylab(bquote(log[2]*FC~Gen~31)) + 
  theme_light() + 
  coord_fixed() +
# Add ablines
  geom_abline(intercept = 0, slope = 0, linetype = "dashed", color = "grey70") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey70") +
  geom_abline(intercept = 0, slope = -1, linetype = "dashed", color = "grey70") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey70")+
  scale_color_manual(values = c("not_sig" = "grey",
                                "shared" = color_shared,
                                "complete_reversed" = color_complete_reversed,
                                "late_response" = color_late_response),
                    name = "", 
                    labels = c(
                      paste("Not significant:", not_sig_nb),
                      paste("Shared:", shared_nb),
                            paste("Complete-reverse:", complete_reversed_nb), 
                            paste("Late-response:", late_response_nb))) + 
  guides(color = guide_legend(override.aes = list(size = 5))) + 
  guides(color = guide_legend(override.aes = list(size = 5))) +
  theme_linedraw() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 16),  
        axis.title = element_text(size = 16),  
        axis.ticks = element_line(size = 1),
        panel.border = element_rect(color = "black", fill = NA, size = 1)) +
  scale_x_continuous(breaks = c(-8, -6, -4, -2, 0, 2, 4, 6, 8), limits = c(-8, 8)) +
  scale_y_continuous(breaks = c(8, -6, -4, -2, 0, 2, 4, 6, 8), limits = c(-8, 8)) 


```
# Summary:
```{r}

# Correlation coefficient - all genes:
pearson_cor <- cor(DE_results_wide$logFCF7, DE_results_wide$logFCF31, method = "pearson")
# Correlation coefficient - only shared DEGs:
shared <- DE_results_wide %>% dplyr::filter(label == "shared")
pearson_cor_shared <- cor(shared$logFCF7, shared$logFCF31, method = "pearson")

# Total number DGEGs at either generation:
total_degs <- nrow(DE_results_wide %>% dplyr::filter(label != "not_sig"))
# Total number DGEGs shared between F7 and F31:
total_shared <- nrow(shared)
# Proportion shared:
prop_shared <- (nrow(shared) / nrow(DE_results_wide %>% dplyr::filter(label != "not_sig"))) * 100
# Total n DGEGs at F7:
degs_F7 <- nrow(DE_results_wide %>% dplyr::filter(label %in% c("F7_specific", "shared")))
# Total n DGEGs at F31:
degs_F31 <- nrow(DE_results_wide %>% dplyr::filter(label %in% c("F31_specific", "shared")))
# Specific DGEGs at F7:
degs_specific_F7 <- nrow(DE_results_wide %>% dplyr::filter(label %in% c("F7_specific")))
# Specific DGEGs at F32:
degs_specific_F31 <- nrow(DE_results_wide %>% dplyr::filter(label %in% c("F31_specific")))

# Proportion Specific DGEGs at F7:
degs_prop_specific_F7 <- nrow(DE_results_wide %>% dplyr::filter(label == "F7_specific")) / nrow(DE_results_wide %>% dplyr::filter(label != "not_sig")) * 100
# Proportion Specific DGEGs at F31:
degs_prop_specific_F31 <- nrow(DE_results_wide %>% dplyr::filter(label == "F31_specific")) / nrow(DE_results_wide %>% dplyr::filter(label != "not_sig")) * 100


# Print summary:
paste("Correlation coefficient all genes:", as.character(pearson_cor))
paste("Correlation coefficient of only shared DEGs:", as.character(pearson_cor_shared))
paste("Total DEGs at either generation:", as.character(total_degs))
paste("Total shared DEGs:", as.character(total_shared))
paste("Proportion of shared DEGs:", as.character(prop_shared))
paste("Total n DGEGs at F7:", as.character(degs_F7))
paste("Total n DGEGs at F31:", as.character(degs_F31))
paste("Specific n DGEGs at F7:", as.character(degs_specific_F7))
paste("Specific n DGEGs at F31:", as.character(degs_specific_F31))

paste("Proportion Specific n DGEGs at F7:", as.character(degs_prop_specific_F7))
paste("proportion Specific n DGEGs at F31:", as.character(degs_prop_specific_F31))

```
# ###################################
# # #### Classify gene trajectories (overall model DEGs)
Classify the trajectories of genes across 3 time points. 
Use p-value and direction of log2FC.
# Prepare dataset:
```{r}
# Remove unnecessary columns:
DE_results_dream_short <- DE_overall_results %>% 
  dplyr::select(c("gene_id","logFC", "contrast", "padj_fdr"))

# From wide to long:
DE_results_wide <- DE_results_dream_short %>%
  pivot_wider(
    names_from = contrast,
    values_from = c(logFC, padj_fdr))

# Change column names:
colnames(DE_results_wide) <- c("gene_id", 
                           "logFC_F7",
                           "logFC_F31", 
                           "logFC_F7_F31",
                           "padj_F7", 
                           "padj_F31",
                           "padj_F7_F31")

```
# Classify genes:
```{r}

# Use classify_DEGs function to classify trajectories across 3 generations:
classify_df <-  classify_DEGs(DE_df = DE_results_wide, alpha_thresh = 0.05, logFC_thresh = 0)
# Check the genes per group:
table(classify_df$group, classify_df$direction)
# Include full group variable:
classify_df$full_group <- paste(classify_df$group, classify_df$direction, sep = "_")
classify_df <- classify_df %>% dplyr::relocate(full_group, .after = direction)
# Format variables:
classify_df$group <- as.factor(classify_df$group)
classify_df$full_group <- as.factor(classify_df$full_group)
# Arrange levels of group:
classify_df$group <-  factor(classify_df$group,
                             levels = c("non_significant",
                                        "plateau", 
                                        "monotonic", 
                                        "incomplete_reversed", 
                                        "complete_reversed", 
                                        "late_response"))



classify_log2FC_filt_df <-  classify_DEGs(DE_df = DE_results_wide, alpha_thresh = 0.05, logFC_thresh = 0.32)
# Check the genes per group:
table(classify_log2FC_filt_df$group, classify_log2FC_filt_df$direction)
# Include full group variable:
classify_log2FC_filt_df$full_group <- paste(classify_log2FC_filt_df$group, classify_log2FC_filt_df$direction, sep = "_")
classify_log2FC_filt_df <- classify_log2FC_filt_df %>% dplyr::relocate(full_group, .after = direction)
# Format variables:
classify_log2FC_filt_df$group <- as.factor(classify_log2FC_filt_df$group)
classify_log2FC_filt_df$full_group <- as.factor(classify_log2FC_filt_df$full_group)
# Arrange levels of group:
classify_log2FC_filt_df$group <-  factor(classify_log2FC_filt_df$group,
                             levels = c("non_significant",
                                        "plateau", 
                                        "monotonic", 
                                        "incomplete_reversed", 
                                        "complete_reversed", 
                                        "late_response"))
```

# Plot - gene trajectories
In order to have one value per gene and simplify the plot we compute
the Median log2CPM across samples of the same generation. 
## Prepare data-set:
```{r}
# Convert gene_id into row names:
count_table_df <- count_table_filt 

# Compute log2CPM:
log2CPM <- edgeR::cpm(as.matrix(count_table_df), 
        normalized.lib.sizes = TRUE,
       log = TRUE)

# Convert gene_id into a column:
log2CPM <- rownames_to_column(as.data.frame(log2CPM), var = "gene_id")

# Include classification information:
group_df <- classify_log2FC_filt_df %>% dplyr::select(c(gene_id, group, direction, full_group))

log2CPM_group <- inner_join(log2CPM, group_df, by = "gene_id")
log2CPM_group <- relocate(log2CPM_group, group, .after = gene_id)
log2CPM_group <- relocate(log2CPM_group, direction, .after = group)
log2CPM_group <- relocate(log2CPM_group, full_group, .after = direction)

# Final data-set:
log2CPM_classify <- log2CPM_group

## Compute mean log2CPM:
#Mean log2CPM of a gene across samples within generation.
# Note: log2CPM_classify has to be ordered properly columnwise!

# Calculate the median of base
log2CPM_classify$F0 <- apply(log2CPM_classify[, 5:9], 1, mean)
# Calculate the median of F7
log2CPM_classify$F07 <- apply(log2CPM_classify[, 10:27], 1, mean)
# Calculate the median of F31
log2CPM_classify$F31 <- apply(log2CPM_classify[, 28:45], 1, mean)

# Keep needed columns:
mean_log2CPM_matrix <- log2CPM_classify %>%
  dplyr::select("gene_id", "group", "direction", "full_group", "F0", "F07", "F31")

# Remove "non significant" genes before scaling:
transform_df <- mean_log2CPM_matrix %>% 
  dplyr::filter(group != "non_significant") 

```
The Median log2CPM of each gene is be scaled across generations. 
```{r}
# Function to compute Z-score:
cal_z_score <- function(x){
  (x - mean(x)) / sd(x)}

# log2CPM to long format:

transform_df <- transform_df %>% pivot_longer(cols = c("F0", "F07", "F31"), 
                                                names_to = "gen", 
                                                values_to = "mean_log2CPM")
# Compute z-scores for each group across generations:
transform_df <- transform_df %>% group_by(gene_id) %>%  
 mutate(scaled_mean_log2CPM = cal_z_score(mean_log2CPM)) %>% ungroup()

scaled_mean_log2CPM_df <- transform_df


# Reorder the factors:
scaled_mean_log2CPM_df$full_group <- factor(scaled_mean_log2CPM_df$full_group,
                                                  levels = c("plateau_up",
                                                             "monotonic_up",
                                                             "late_response_up",
                                                             "incomplete_reversed_up",
                                                             "complete_reversed_up",
                                                             "plateau_down",
                                                             "monotonic_down",
                                                             "late_response_down",
                                                             "incomplete_reversed_down",
                                                             "complete_reversed_down"))
```

## Plot mean log2CPM
```{r}
## Set facet tittles:
facet_labels <- c(
  "plateau_up" = "Plateau up",
  "plateau_down" = "Plateau down",
  "monotonic_up" = "Evolving Monotonic up",
  "monotonic_down" = "Evolving Monotonic down",
  "incomplete_reversed_up" = "Incomplete Reversed up",
  "incomplete_reversed_down" = "Incomplete Reversed down",
  "complete_reversed_up" = "Complete Reversed up",
  "complete_reversed_down" = "Complete Reversed down",
  "late_response_up" = "Late Response up",
  "late_response_down" = "Late Response down")

# Label number of genes;
my_tag <- c(paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "plateau_up")))),
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "plateau_down")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "evolving_up")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "evolving_down")))),
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "F31_private_up")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "F31_private_down")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "reversed_up")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "reversed_down")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "F7_private_up")))), 
            paste("N=", as.character(nrow(classify_df %>% dplyr::filter(full_group == "F7_private_down")))))

# Change generation scale to reduce distances proportionally:
scaled_mean_log2CPM_df <- scaled_mean_log2CPM_df %>%
  dplyr::mutate(gen2 = case_when(gen == "F0" ~ 0, 
                                gen == "F07" ~ 0.5,
                                gen == "F31" ~ 2))


scaled_mean_log2CPM_df %>% 
  ggplot(aes(x = gen2, y = mean_log2CPM, group=interaction(full_group, gen2))) +
  geom_boxplot(aes(color = full_group), width=0.4) +
  scale_color_manual(values =  c(color_plateau, 
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed,
                               color_plateau, 
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed)) +
  facet_wrap(~ full_group,
             scale = "free_y",
             ncol = 5, nrow = 2,
             labeller = as_labeller(facet_labels)) +
  xlab("Generation") + 
  ylab(bquote(Mean~expression~change~log[2]*FC)) +
  theme_linedraw() +
  theme(strip.text = element_text(color = "black",
                                  size = 14),
        strip.background = element_blank(),
        legend.position = "none",
        plot.background = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        element_text(size=14),
        axis.text.y = element_text(size = 14,
                                   color = "black"),
                axis.text.x = element_text(size = 14,
                                   color = "black"),
        axis.ticks = element_line(colour = "black",
                                  size = 1)) + 
  scale_x_continuous(breaks = c(0, 0.5, 2), labels = c("0", "7", "31"))


```
## Plot z-score 
The Median log2CPM of each gene is be scaled across generations. 
```{r}

scaled_mean_log2CPM_df %>% 
  ggplot(aes(x = gen2, y = scaled_mean_log2CPM, group=interaction(full_group, gen2))) +
  geom_boxplot(aes(color = full_group), width=0.4) +
  scale_color_manual(values =  c(color_plateau, 
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed,
                               color_plateau, 
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed)) +
  facet_wrap(~ full_group,
             scale = "free_y",
             ncol = 5, nrow = 2,
             #labeller = as_labeller(facet_labels)
             ) +
  xlab("Generation") + 
  ylab("Expression (mean log2CPM") + 
  theme_linedraw() +
  theme(strip.text = element_text(color = "black",
                                  size = 14),
        strip.background = element_blank(),
        legend.position = "none",
        plot.background = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        element_text(size=14),
        axis.text.y = element_text(size = 14,
                                   color = "black"),
                axis.text.x = element_text(size = 14,
                                   color = "black"),
        axis.ticks = element_line(colour = "black",
                                  size = 1)) + 
  scale_x_continuous(breaks = c(0, 0.5, 2), labels = c("0", "7", "31"))


```
## Plot Heat-map:
The Median log2CPM of each gene is be scaled across generations. 
```{r}
# Create data with log2CPM:
data <- log2CPM_group %>% dplyr::filter(group %in% c("monotonic",
                                                   "late_response")) 
data <- data %>% column_to_rownames("gene_id")
data <- data %>% arrange(full_group)
# Create a data frame for row annotation (groups)
group_df <- data.frame(full_group = factor(data$full_group))
row.names(group_df) <- rownames(data)
# Subset log2CPM values:
data <- data[,4:44] 

ann_df <- data.frame(generation = rep(c("Base", "F7", "F31"), c(5, 18, 18)))
row.names(ann_df) <- colnames(data)


# Create metadata:
filter_group_df <- log2CPM_group %>%
  dplyr::filter(full_group %in% c("monotonic_up",
                                  "monotonic_down",
                                  "late_response_up",
                                  "late_response_down"))
filter_ann_colors <- list(
  full_group =  c("monotonic_up" = "#b3de69",
             "monotonic_down" = "#31a354",
             "late_response_up" = "#bd0026",
             "late_response_down" = "#e31a1c"),
  
  generation = c("Base" = "orange",
              "F7" = "#af8dc3",
            "F31" = "#762a83"))
 
heat_plot1 <- pheatmap(data,
                      scale = "row",
                      col = brewer.pal(9, 'YlOrRd'), # choose a colour scale for your data
                      cluster_rows = F, 
                      cluster_cols = F, # set to FALSE if you want to remove the dendograms
                      clustering_distance_cols = 'euclidean',
                      clustering_distance_rows = 'euclidean',
                      clustering_method = 'ward.D',
                      annotation_row = group_df, # row (gene) annotations
                      annotation_col = ann_df, # column (sample) annotations
                      annotation_colors = filter_ann_colors, # colours for your annotations
                      annotation_names_row = F, 
                      annotation_names_col = F,
                      fontsize_row = 10,          # row label font size
                      fontsize_col = 7,          # column label font size 
                      angle_col = 90, # sample names at an angle
                      legend_breaks = c(-4,  4), # legend customisation
                      legend_labels = c("Low",  "High"), # legend customisation
                      show_colnames = T, show_rownames = F, # displaying column and row names
                      main = "scaled log2CPM DEGs") # a title for our heatmap
heat_plot1

```

```{r}
# Create data with log2CPM:
data <- log2CPM_group %>% dplyr::filter(group %in% c("complete_reversed",
                                                   "incomplete_reversed")) 
data <- data %>% column_to_rownames("gene_id")
data <- data %>% arrange(full_group)
# Create a data frame for row annotation (groups)
group_df <- data.frame(full_group = factor(data$full_group))
row.names(group_df) <- rownames(data)
# Subset log2CPM values:
data <- data[,4:44] 

ann_df <- data.frame(generation = rep(c("Base", "F7", "F31"), c(5, 18, 18)))
row.names(ann_df) <- colnames(data)


filter_group_df <- group_df %>%
  dplyr::filter(full_group %in% c("incomplete_reversed_up",
                                  "incomplete_reversed_down",
                                  "complete_reversed_up",
                                  "complete_reversed_down"))
filter_ann_colors <- list(
  full_group =  c("incomplete_reversed_up" = "#fdb479",
             "incomplete_reversed_down" = "#fdb930",
             "complete_reversed_up" = "#1dd3c9",
             "complete_reversed_down" = "#41b6c4"), 
  
  generation = c("Base" = "orange",
              "F7" = "#af8dc3",
            "F31" = "#762a83"))
 
##### 
heat_plot2 <- pheatmap(data,
                      scale = "row",
                      col = brewer.pal(9, 'YlOrRd'), # choose a colour scale for your data
                      cluster_rows = F, 
                      cluster_cols = F, # set to FALSE if you want to remove the dendograms
                      clustering_distance_cols = 'euclidean',
                      clustering_distance_rows = 'euclidean',
                      clustering_method = 'ward.D',
                      annotation_row = filter_group_df, # row (gene) annotations
                      annotation_col = ann_df, # column (sample) annotations
                      annotation_colors = filter_ann_colors, # colours for your annotations
                      annotation_names_row = F, 
                      annotation_names_col = F,
                      fontsize_row = 10,          # row label font size
                      fontsize_col = 7,          # column label font size 
                      angle_col = 90, # sample names at an angle
                      legend_breaks = c(-4,  4), # legend customisation
                      legend_labels = c("Low",  "High"), # legend customisation
                      show_colnames = T, show_rownames = F, # displaying column and row names
                      main = "scaled log2CPM DEGs") # a title for our heatmap
heat_plot2
```


```{r}
data <- log2CPM_group %>% dplyr::filter(group == "plateau") 
data <- data %>% column_to_rownames("gene_id")
data <- data %>% arrange(full_group)
# Create a data frame for row annotation (groups)
group_df <- data.frame(full_group = factor(data$full_group))
row.names(group_df) <- rownames(data)
# Subset log2CPM values:
data <- data[,4:44] 

ann_df <- data.frame(generation = rep(c("Base", "F7", "F31"), c(5, 18, 18)))
row.names(ann_df) <- colnames(data)

filter_group_df <- group_df %>%
  dplyr::filter(full_group %in% c("plateau_up",
                                  "plateau_down"))
filter_ann_colors <- list(
  full_group =  c("plateau_up" = "#3182bd",
             "plateau_down" = "#99b9d9"), 
  generation = c("Base" = "orange",
              "F7" = "#af8dc3",
            "F31" = "#762a83"))
 
heat_plot3 <- pheatmap(data,
                      scale = "row",
                      col = brewer.pal(9, 'YlOrRd'), # choose a colour scale for your data
                      cluster_rows = F, 
                      cluster_cols = F, # set to FALSE if you want to remove the dendograms
                      clustering_distance_cols = 'euclidean',
                      clustering_distance_rows = 'euclidean',
                      clustering_method = 'ward.D',
                      annotation_row = filter_group_df, # row (gene) annotations
                      annotation_col = ann_df, # column (sample) annotations
                      annotation_colors = filter_ann_colors, # colours for your annotations
                      annotation_names_row = F, 
                      annotation_names_col = F,
                      fontsize_row = 10,          # row label font size
                      fontsize_col = 7,          # column label font size 
                      angle_col = 90, # sample names at an angle
                      legend_breaks = c(-4,  4), # legend customisation
                      legend_labels = c("Low",  "High"), # legend customisation
                      show_colnames = T, show_rownames = F, # displaying column and row names
                      main = "scaled log2CPM DEGs") # a title for our heatmap
heat_plot3

```
## Plot log2FC:
### Create classify_df_long:
Base is set artificially at 0 for all log2FC values to have a basal point 
from where to start the trajectories. 
```{r}
# Prepare data-set:
classify_df_long <-  classify_log2FC_filt_df %>% dplyr::select(-c(padj_F7,
                                                      padj_F31,
                                                      padj_F7_F31,
                                                      logFC_F7_F31 ))

classify_df_long <- pivot_longer(classify_df_long,
                                 cols = starts_with("logFC"),
                                 names_to = "contrast",
                                 values_to = "logFC")

classify_df_long$contrast <- factor(classify_df_long$contrast,
                                    levels = c("logFC_F7",
                                               "logFC_F31"))

table(classify_df_long$group)

```

```{r}
pu <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="plateau_up") %>% dplyr::select(gene_id),  
  full_group = "plateau_up",                   
  contrast = "Base",                
  logFC = 0 )

pd <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="plateau_down") %>% dplyr::select(gene_id),  
  full_group = "plateau_down",                   
  contrast = "Base",                
  logFC = 0 )

eu <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="monotonic_up") %>% dplyr::select(gene_id),  
  full_group = "monotonic_up",                   
  contrast = "Base",                
  logFC = 0 )

ed <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="monotonic_down") %>% dplyr::select(gene_id),  
  full_group = "monotonic_down",                   
  contrast = "Base",                
  logFC = 0 )

ru <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="incomplete_reversed_up") %>% dplyr::select(gene_id),  
  full_group = "incomplete_reversed_up",                   
  contrast = "Base",                
  logFC = 0 )

rd <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="incomplete_reversed_down") %>% dplyr::select(gene_id),  
  full_group = "incomplete_reversed_down",                   
  contrast = "Base",                
  logFC = 0)

pr7u <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="complete_reversed_up") %>% dplyr::select(gene_id),  
  full_group = "complete_reversed_up",                   
  contrast = "Base",                
  logFC = 0)

pr7d <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="complete_reversed_down") %>% dplyr::select(gene_id),  
  full_group = "complete_reversed_down",                   
  contrast = "Base",                
  logFC = 0)

pr31u <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="late_response_up") %>%
    dplyr::select(gene_id),  
  full_group = "late_response_up",                   
  contrast = "Base",                
  logFC = 0)

pr31d <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(full_group=="late_response_down") %>%
    dplyr::select(gene_id),  
  full_group = "late_response_down",                   
  contrast = "Base",                
  logFC = 0)

non_significant <- data.frame(
  gene_id = classify_df_long %>%
    dplyr::filter(group == "non_significant") %>%
    dplyr::select(gene_id),  
  full_group = "non_significant_none",                   
  contrast = "Base",                
  logFC = 0)

classify_df_long_temp <- classify_df_long %>%
  dplyr::select(gene_id, full_group, contrast, logFC)

classify_df_long_base0 <- rbind(classify_df_long_temp, pu, pd,
                                eu, ed, pr7u, pr7d,
                                pr31u, pr31d, ru, rd)
table(classify_df_long_base0$full_group)


classify_df_long_base0_full <- rbind(classify_df_long_temp, pu, pd,
                                eu, ed, pr7u, pr7d,
                                pr31u, pr31d, ru, rd, non_significant)
classify_df_long_base0_full <- classify_df_long_base0_full %>% mutate(full_group = case_when(full_group == "transitory_F7_F31_none" ~ "non_significant_none", TRUE ~ full_group))


```

```{r}
# Plotting: Dotplot + Lineplot
classify_df_long_base0$full_group <- factor(classify_df_long_base0$full_group,
                                       levels = c("plateau_up", "plateau_down",
                                                  "monotonic_up", "monotonic_down",
                                                  "late_response_up", "late_response_down",
                                                  "incomplete_reversed_up", "incomplete_reversed_down",
                                                  "complete_reversed_up", "complete_reversed_down"))

classify_df_long_base0$contrast <- factor(classify_df_long_base0$contrast,
                                          levels = c("Base", "logFC_F7","logFC_F31"))

##
classify_df_long_base0 <- classify_df_long_base0 %>%
  dplyr::mutate(generation = case_when(contrast == "Base"~ 0,
                                       contrast == "logFC_F7"~ 7,
                                       contrast == "logFC_F31"~ 31))

# Include group:
classify_df_long_base0_full <- classify_df_long_base0_full %>%
  mutate(group = case_when(grepl("plateau", full_group) ~ "plateau",
                           grepl("monotonic", full_group) ~ "monotonic",
                          grepl("incomplete_reversed_", full_group) ~ "incomplete_reversed",
                          grepl("complete", full_group) ~ "complete_reversed",
                          grepl("late_response", full_group) ~ "late_response",
                          grepl("non_significant", full_group) ~ "non_significant"))

classify_df_long_base0_full <- classify_df_long_base0_full %>%
  dplyr::mutate(generation = case_when(contrast == "Base"~ 0,
                                       contrast == "logFC_F7"~ 7,
                                       contrast == "logFC_F31"~ 31))

# Calculate median and confidence intervals
summary_data <- classify_df_long_base0_full %>%
  group_by(generation, group) %>%
  summarise(
    mean_value = mean(abs(logFC)),
    ci_lower = quantile(abs(logFC), 0.25),
    ci_upper = quantile(abs(logFC), 0.75),
    .groups = 'drop')


summary_data$group <- factor(summary_data$group,
                             levels = c("non_significant","plateau",
                                "monotonic",
                                "late_response",
                               "incomplete_reversed",
                               "complete_reversed"))


ggplot(summary_data, aes(x = as.numeric(generation),
                                 y = abs(mean_value),
                                 color = group)) +
  geom_line(alpha = 3, size=3) + 
  scale_color_manual(values = c("#f0f0f0",color_plateau,
                                color_monotonic,
                                color_late_response,
                               color_incomplete_reversed,
                               color_complete_reversed)) +  
  theme_classic() +
  theme(
    axis.text = element_text(size = 14, color = "black"),
    strip.background = element_blank(),
    axis.title.y = element_text(size=14),
    axis.title.x = element_text(size=14),
    legend.title = element_text(size = 14),  
    legend.text = element_text(size = 14),  
    axis.line = element_line(color = "black"),  
    axis.ticks = element_line(color = "black")) +
  xlab("Generation") +
  ylab(bquote(Mean~expression~change~Abs.~log[2]*FC)) +
  coord_cartesian(ylim = c(0, 2)) +
  theme(legend.position = "right") + geom_hline(yintercept = 0.32, linetype = "dashed") 

# Save plot:
#ggsave("/Users/cramirez/Desktop/github_repositories/BigCages_high_protein/output_files/plots/correlation_plots_and_trajectories/mean_logFC_trajectories.svg", last_plot())

```
## Plot scatter plots:
```{r}
## Plot 3 groups with similar x and y axis:

classify_log2FC_filt_df %>% dplyr::filter(group %in% c("plateau",
                                           "monotonic",
                                           "incomplete_reversed",
                                           "complete_reversed",
                                           "late_response")) %>% 
  ggplot(aes(x = logFC_F7, y = logFC_F31, colour = group)) + 
  geom_point(size=2, shape=16, alpha=0.5) +
  xlab(bquote(log[2]*FC~Gen~7)) + 
  ylab(bquote(log[2]*FC~Gen~31)) + 
  theme_light() + 
  #coord_fixed() +
# Add ablines
  geom_abline(intercept = 0, slope = 0, linetype = "dashed", color = "grey70") +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey70") +
  geom_abline(intercept = 0, slope = -1, linetype = "dashed", color = "grey70") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey70")+
  scale_color_manual(values = c("plateau" = color_plateau,
                                "monotonic" = color_monotonic,
                                "incomplete_reversed" = color_incomplete_reversed,
                                "complete_reversed" = color_complete_reversed,
                                "late_response" = color_late_response)) +
  guides(color = guide_legend(override.aes = list(size = 5))) + 
  guides(color = guide_legend(override.aes = list(size = 5))) +
  theme_linedraw() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 16),  
        axis.title = element_text(size = 16),  
        axis.ticks = element_line(size = 1),
        panel.border = element_rect(color = "black", fill = NA, size = 1))  +
  scale_x_continuous(breaks = c(-8, -4, 0, 4, 8), limits = c(-8, 8)) +
  scale_y_continuous(breaks = c(-8, -4, 0, 4, 8), limits = c(-8, 8)) +
  facet_wrap(~ group, nrow=2) +
  geom_hline(yintercept = 0.32, linetype = "dashed", color= "red") +
  geom_vline(xintercept = 0.32, linetype = "dashed", color= "red") +
  geom_hline(yintercept = -0.32, linetype = "dashed", color= "red") +
  geom_vline(xintercept = -0.32, linetype = "dashed", color= "red")

```


# Summary:
```{r}
table(classify_log2FC_filt_df$group)

# Total DEGs
total_DEGs <- nrow(classify_log2FC_filt_df %>% dplyr::filter(!group %in% c("non_significant", "transitory_F7_F31")))

# Number of plateau genes:
plateau_DEGs <- nrow(classify_log2FC_filt_df %>% dplyr::filter(group == "plateau"))
# Proportion plateau:
prop_plateau <- plateau_DEGs / total_DEGs * 100

# Number of monotonic genes:
monotonic_DEGs <- nrow(classify_log2FC_filt_df %>% dplyr::filter(group == "monotonic"))
# Proportion monotonic:
prop_monotonic <- monotonic_DEGs / total_DEGs * 100

# Number of incomplete reverse genes:
inc_reverse_DEGs <- nrow(classify_log2FC_filt_df %>% dplyr::filter(group == "incomplete_reversed"))
# Proportion monotonic:
prop_inc_reverse <- inc_reverse_DEGs / total_DEGs * 100

# Number of complete reverse genes:
c_reverse_DEGs <- nrow(classify_log2FC_filt_df %>% dplyr::filter(group == "complete_reversed"))
# Proportion monotonic:
prop_c_reverse <- c_reverse_DEGs / total_DEGs * 100

# Number of complete reverse genes:
late_response_DEGs <- nrow(classify_log2FC_filt_df %>% dplyr::filter(group == "late_response"))
# Proportion monotonic:
prop_late_response <- late_response_DEGs / total_DEGs * 100


# Print summary:
paste("Number of DEGs:", as.character(total_DEGs))

paste("Number of plateau DEGs:", as.character(plateau_DEGs))
paste("Proportion plateau DEGs:", as.character(prop_plateau))

paste("Number of monotonic DEGs:", as.character(monotonic_DEGs))
paste("Proportion monotonic DEGs:", as.character(prop_monotonic))

paste("Number of incomplete reverse DEGs:", as.character(inc_reverse_DEGs))
paste("Proportion incomplete reverse DEGs:", as.character(prop_inc_reverse))

paste("Number of complete reverse DEGs:", as.character(c_reverse_DEGs))
paste("Proportion complete reverse DEGs:", as.character(prop_c_reverse))

paste("Number of late response DEGs:", as.character(late_response_DEGs))
paste("Proportion late response DEGs:", as.character(prop_late_response))

```
# Fig. S11 B - Pie chart
```{r}
# remove non_significant genes:
filt_df <- classify_log2FC_filt_df %>% dplyr::filter(!group %in%
                                                       c("non_significant")) %>% droplevels()

filt_df$group <- factor(filt_df$group, levels = c("plateau",
                                                  "complete_reversed",
                                                  "incomplete_reversed",
                                                  "late_response",
                                                  "monotonic"))
manual_palette = c(color_plateau,
                   color_complete_reversed,
                   color_incomplete_reversed,
                   color_late_response,
                   color_monotonic)
# Donut chart
donutchart <-  lessR::PieChart(group,
                       data = filt_df,
                       main = NULL,
                       color="white",
                       labels_size = 1.3,
                       fill = manual_palette)

#Export plot: 
#ggsave("output_files/plots/correlation_plots_and_trajectories/pie_chart_trajectories_filtering_log2FC.svg")

```

--- END ---